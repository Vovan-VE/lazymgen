#!/usr/bin/env perl6

use v6.c;

my constant $PROJECT_NAME = 'Lazy Migration Generator';
my constant $PROJECT_VER  = '0.0.1';

class X::App::MatchFail is X::AdHoc {}
class X::App::Runtime is X::AdHoc {}
class X::App::Unsupported is X::App::Runtime {}
class X::App::IO is X::App::Runtime {}

class X::App::Abort is X::AdHoc {
    multi method gist(X::App::Abort:D:) { $.payload }
}

my \IS_I = INIT { $*IN.t && $*OUT.t };

sub abort(Str:D $message) {
    die X::App::Abort.new(payload => $message);
}

grammar MigrationSource {
    token ws { <!ww> \h* }

    token number {
        <[- +]>?
        [ 0 || <[1..9]> \d* ]
        [ '.' \d+ ]?
        [ :i <[-+]>? e <[- +]>? \d+ ]?
    }
    token string { \' ~ \' [ <-[' \\]>+ || \\ . ]* }
    token value_keyword { :i <<[TRUE|FALSE|NULL]>> }
    token name {
        <!before <[ - \d ]> >
        [ [ <[ _ a..z \d ]>+ | \\ . ]+ ]+ % '-'+
    }
    token null_mark { '?' }

    rule default_value {
        ['=' <!before '>'>] ~ [
            [<number> | <string>]
            || <value_keyword>
        ] <?> }
    rule params { '(' ~ ')' [ <number>* % ',' ] }
    rule type {
        [':' ~ <name> <?>]
        <params>?
        <null_mark>?
        <default_value>?
    }
    rule column_definition { <name> ~ <type> <?> }

    rule create_table_body { '(' ~ ')' [ <column_definition>* % ',' ] }

    token pos_first { '^' }
    token pos_after { '>' }
    rule position { <pos_first> | [<pos_after> ~ <name> <?>] }
    rule alter_column_type { <type> <position>? }

    token alias { '@' ~ <name> <?> }
    token table { '%' ~ <name> <?> }

    rule alter_column_name { '=>' ~ <name> <?> }
    rule alter_column_spec {
        <alter_column_name>
        | <from=alter_column_type> ~ [ '=>' ~ <to=alter_column_type> <?> ] <?>
    }
    rule alter_column { '.' ~ [<name> ~ <alter_column_spec> <?>] <?> }
    rule rename_table { '=>' ~ <table> <?> }

    rule table_columns_ref {
        <table>
        ~
        ['.' ~ <columns=name> ** 1 <?> | '(' ~ ')' [ <columns=name>+ % ',' ]]
        <?>
    }

    token fk_restrict { '!' }
    token fk_cascade { '>' }
    token fk_set_null { '?' }
    token fk_verb { <fk_restrict> | <fk_cascade> | <fk_set_null> }
    token fk_on_delete { '~' ~ <fk_verb> <?> }
    token fk_on_update { '*' ~ <fk_verb> <?> }
    rule fk_statement {
        <<FK>> ~ [
            <alias>? ~ [
                <source=table_columns_ref> ~ [
                    '=>' ~ <target=table_columns_ref> <?>
                ] <?>
            ] <?>
        ] <?>
        [
            <fk_on_delete> <fk_on_update>?
            | <fk_on_update> <fk_on_delete>?
        ]?
    }

    token index_type { << [I | U | PK] >> }
    rule key_statement {
        <index_type> ~ [
            <alias>? ~ <table_columns_ref> <?>
        ] <?>
    }

    rule add_column_body { '.' ~ [<name> ~ <alter_column_type> <?>] <?> }
    rule table_ddl_statement {
        <table> ~ [<create_table_body> | <add_column_body>] <?>
    }

    rule ddl_statement {
        <table_ddl_statement>
        | <key_statement>
        | <fk_statement>
    }

    rule create_statement { '+' ~ <ddl_statement> <?> }
    rule drop_statement { '-' ~ <ddl_statement> <?> }
    rule data_statement { '=' }
    rule alter_statement {
        '*' ~ [
            <table> ~ [<rename_table> | <alter_column>] <?>
        ] <?>
    }

    rule statement {
        ^^ ~ $$
        [
            <create_statement>
            | <drop_statement>
            | <alter_statement>
            | <data_statement>
        ]
    }
    rule TOP { <statement>* % [$ | \n] }

    method FAILGOAL($goal) {
        my $after = self.target.substr((self.pos - 10 max 0) ..^ self.pos);
        $after = $after
            ?? ' after `' ~ (self.pos > 10 ?? '...' !! '') ~ $after ~ '`'
            !! "";
        my $near = self.pos < self.target.chars
            ?? 'near `'
                ~ self.target.substr(self.pos, 10)
                ~ (self.pos < self.target.chars - 10 ?? '...' !! '')
                ~ '`'
            !! 'instead of EOF';
        die X::App::MatchFail.new(
            payload => "expected `{$goal.trim}`{$after} {$near} at position {self.pos}"
        );
    }
}

class Statement {
    has Str:D $.name = '';
    has Str:D $.code = '';

    submethod TWEAK() {
        $!name = self.filter-name($!name);
    }

    multi method gist(Statement: --> Str) {
        "`$!name` ⟨\n" ~
        $!code.indent(4) ~ "\n" ~
        "⟩";
    }

    method filter-name(Str:D $name --> Str:D) { $name }
}

class Migration {
    has Match:D     $.source is required;
    has Str:D       @.header;
    has Statement:D $.up     is required;
    has Statement:D $.down   is required;

    method BUILDALL(|) {
        @!header.unshift(
            "Generated with $PROJECT_NAME/$PROJECT_VER",
        );

        callsame;

        @!header.push(
            "",
            "Source:",
            "    $!source",
        );

        self;
    }

    multi method gist(Migration: --> Str) {
        '$> ' ~ self.up.name ~ "\n" ~
        @!header.map({
            "> $_".trim.indent(4) ~ "\n"
        }).join ~
        (UP => self.up, DOWN => self.down).map({
            (
                .key ~ ":\n" ~
                .value.gist.indent(4)
            ).indent(4) ~ "\n"
        }).join ~
        '.';
    }
}

role TransformFormat {
    # Export matched statement to complete migration code
    method make-migration(Match:D $s --> Migration) {
        Migration.new(
            source => $s,
            up     => self.statement($s),
            down   => self.statement($s, :back),
        );
    }

    method create-table(Match:D $s --> Statement) {...}
    method drop-table  (Match:D $s --> Statement) {...}

    method add-column (Match:D $s --> Statement) {...}
    method drop-column(Match:D $s --> Statement) {...}

    method add-primary-key (Match:D $s --> Statement) {...}
    method drop-primary-key(Match:D $s --> Statement) {...}

    method add-unique-key (Match:D $s --> Statement) {...}
    method drop-unique-key(Match:D $s --> Statement) {...}

    method add-index (Match:D $s --> Statement) {...}
    method drop-index(Match:D $s --> Statement) {...}

    method add-foreigh-key (Match:D $s, Bool:D :$back = False --> Statement) {...}
    method drop-foreign-key(Match:D $s, Bool:D :$back = False --> Statement) {...}

    method rename-table(Match:D $s, Bool:D :$back = False --> Statement) {...}

    method alter-column-name(Match:D $s, Bool:D :$back = False --> Statement) {...}
    method alter-column-type(Match:D $s, Bool:D :$back = False --> Statement) {...}

    method data-statement(Match:D $s, Bool:D :$back = False --> Statement) {...}

    method statement(Match:D $s, Bool:D :$back = False --> Statement) {
        my $caps = $s.caps;
        unless 1 === $caps.elems {
            die "expected Match under `<statement>` but got `{$s.caps[0]}`";
        }
        given $caps[0] {
            when .key eq 'create_statement' {
                self.ddl-statement(.value<ddl_statement>, :$back);
            }
            when .key eq 'drop_statement' {
                self.ddl-statement(.value<ddl_statement>, back => !$back);
            }
            when .key eq 'alter_statement' {
                my $st = .value;
                if $st<rename_table>:exists {
                    return self.rename-table($st, :$back);
                }
                my $alt = $st<alter_column><alter_column_spec>;
                if $alt<alter_column_name>:exists {
                    return self.alter-column-name($st, :$back);
                }
                return self.alter-column-type($st, :$back);
            }
            when .key eq 'data_statement' {
                return self.data-statement(.value, :$back);
            }
            default {
                die "expected Match under `<statement>` but got `{.key}`";
            }
        }
    }

    method ddl-statement(Match:D $s, Bool:D :$back = False --> Statement) {
        given $s.caps[0] {
            when .key eq 'table_ddl_statement' {
                if .value<create_table_body>:exists {
                    return self.create-table(.value) unless $back;
                    return self.drop-table(.value);
                }
                return self.add-column(.value) unless $back;
                return self.drop-column(.value);
            }
            when .key eq 'key_statement' {
                my $st = .value;
                given $st<index_type>.Str.uc {
                    when 'PK' {
                        return self.add-primary-key($st) unless $back;
                        return self.drop-primary-key($st);
                    }
                    when 'U' {
                        return self.add-unique-key($st) unless $back;
                        return self.drop-unique-key($st);
                    }
                    when 'I' {
                        return self.add-index($st) unless $back;
                        return self.drop-index($st);
                    }
                    default {
                        die "unexpected index type `$_`";
                    }
                }
            }
            when .key eq 'fk_statement' {
                return self.add-foreigh-key(.value) unless $back;
                return self.drop-foreign-key(.value);
            }
            default {
                die "expected Match under `<ddl_statement>` but got `{.key}`";
            }
        }
    }

    method table(Match:D $t --> Str) {
        return self.name($t<name>);
    }

    method default-value(Match:D $v --> Str) {
        return $v<number>.Str           if $v<number>:exists;
        return $v<value_keyword>.Str.lc if $v<value_keyword>:exists;
        return self.string(
            $v<string>.Str
                .substr(1, *-1)
                .subst(/\\(.)/, { $0 }, :g)
        );
    }

    method name(Match:D $m --> Str) {
        $m.Str.subst(/\\ (.)/, { $0 }, :g);
    }

    method string(Str:D $s --> Str) { $s }

    method throw-unsupported(Str:D $message) {
        die X::App::Unsupported.new(payload => $message);
    }
}

role MigrationExporter {
    method export(Migration:D $migration --> Bool) { ... }
}

class DebugExporter does MigrationExporter {
    has IO::Handle $!to = $*OUT;

    method export(Migration:D $migration --> Bool) {
        $!to.say($migration);
    }
}

class Yii2Statement is Statement {
    method filter-name(Str:D $name --> Str:D) {
        $name.subst(/ :i <-[ a..z \d ]>+ /, '_', :g);
    }
}

class Yii2Migration is Migration {
    has Str:D $.indent = '';

    method BUILDALL(|) {
        self.header.unshift("Format: Yii2");

        callsame;
        self;
    }
}

class Yii2Format does TransformFormat {
    my constant UNSIGNED         = '->unsigned()';
    my constant MAX_INDEX_LENGTH = 64;

    my constant %types = {
        primary      => {:t<primaryKey>,    :D},
        uprimary     => {:T<primaryKey>,    :D, :a(UNSIGNED)},
        primary-big  => {:t<bigPrimaryKey>, :D},
        uprimary-big => {:t<bigPrimaryKey>, :D, :a(UNSIGNED)},
        char         => True,
        string       => True,
        text         => True,
        int16        => 'smallInteger',
        uint16       => ['smallInteger', UNSIGNED],
        int          => 'integer',
        uint         => ['integer', UNSIGNED],
        bigint       => 'bigInteger',
        int64        => 'bigInteger',
        uint64       => ['bigInteger', UNSIGNED],
        float        => True,
        double       => True,
        decimal      => True,
        date         => True,
        datetime     => 'dateTime',
        time         => True,
        timestamp    => True,
        binary       => True,
        bool         => 'boolean',
        money        => True,
    };

    my constant FK_ACTION = {
        fk_restrict => 'RESTRICT',
        fk_cascade  => 'CASCADE',
        fk_set_null => 'SET NULL',
    };

    my constant S_FK = 'fk';
    my constant S_PK = 'pk';
    my constant S_IDX = 'idx';

    method data-types(--> Iterable) {
        %types.keys;
    }

    method make-migration(Match:D $s --> Migration) {
        Yii2Migration.new(
            source => $s,
            up     => self.statement($s),
            down   => self.statement($s, :back),
        );
    }

    method create-table(Match:D $s --> Yii2Statement) {
        my ($table, $create) = $s<table create_table_body>;
        Yii2Statement.new(
            :name("create_{self.table($table)}"),
            :code(
                '$tableOptions = null;' ~ "\n" ~
                q[if ($this->db->driverName === 'mysql') {] ~ "\n" ~
                (
                    '// https://stackoverflow.com/q/766809' ~ "\n" ~
                    q[$tableOptions = 'CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE=InnoDB';]
                ).indent(4) ~ "\n" ~
                "}\n" ~
                "\n" ~
                '$this->createTable(' ~ self.table-string($table) ~ ", [\n" ~
                $create<column_definition>.list.map({
                    my ($name, $type) = .hash<name type>;
                    self.name-string($name) ~ ' => ' ~ self.column-type($type) ~ ',';
                }).join("\n").indent(4) ~ "\n" ~
                '], $tableOptions);'
            ),
        );
    }
    method drop-table(Match:D $s --> Yii2Statement) {
        my ($table) = $s<table>;
        Yii2Statement.new(
            :name("drop_{self.table($table)}"),
            :code('$this->dropTable(' ~ self.table-string($table) ~ ');')
        );
    }

    method add-column(Match:D $s --> Yii2Statement) {
        my ($table, $add_col) = $s<table add_column_body>;
        my ($column, $type_pos) = $add_col<name alter_column_type>;
        Yii2Statement.new(
            :name("add_{self.table($table)}_{self.name($column)}"),
            :code(
                '$this->addColumn(' ~ "\n" ~
                (
                    self.table-string($table) ~ ",\n" ~
                    self.name-string($column) ~ ",\n" ~
                    self.column-type-pos($type_pos)
                ).indent(4) ~ "\n" ~
                ');'
            )
        );
    }
    method drop-column(Match:D $s --> Yii2Statement) {
        my ($table, $add_col) = $s<table add_column_body>;
        my ($column) = $add_col<name>;
        Yii2Statement.new(
            :name("drop_{self.table($table)}_{self.name($column)}"),
            :code(
                '$this->dropColumn(' ~
                self.table-string($table) ~ ', ' ~
                self.name-string($column) ~
                ');'
            )
        );
    }

    method add-primary-key(Match:D $s --> Yii2Statement) {
        self!index-common($s, 'add_', 'addPrimaryKey', S_PK, :cols);
    }
    method drop-primary-key(Match:D $s --> Yii2Statement) {
        self!index-common($s, 'drop_', 'dropPrimaryKey', S_PK);
    }

    method add-unique-key(Match:D $s --> Yii2Statement) {
        self!index-common($s, 'add_', 'createIndex', S_IDX, :cols, :tag<true>);
    }
    method drop-unique-key(Match:D $s --> Yii2Statement) {
        self!index-common($s, 'drop_', 'dropIndex', S_IDX);
    }

    method add-index(Match:D $s --> Yii2Statement) {
        self!index-common($s, 'add_', 'createIndex', S_IDX, :cols, :tag<false>);
    }
    method drop-index(Match:D $s --> Yii2Statement) {
        self!index-common($s, 'drop_', 'dropIndex', S_IDX);
    }

    method !index-common(Match:D $s, Str $namePrefix, Str $method, Str $prefix, Bool:D :$cols = False, Str :$tag --> Yii2Statement) {
        my ($alias, $ref) = $s<alias table_columns_ref>;
        my $index_name = self.index-name($prefix, $alias, $ref);
        Yii2Statement.new(
            :name($namePrefix ~ $index_name),
            :code(
                '$this->' ~ $method ~ "(\n" ~
                (
                    self.string($index_name) ~ ",\n" ~
                    self.table-string($ref<table>) ~
                    ($cols
                        ?? ",\n[" ~
                        $ref<columns>.list.map({
                            self.name-string($_)
                        }).join(', ') ~ ']'
                        !! ''
                    ) ~
                    ($tag
                        ?? ",\n$tag"
                        !! ''
                    )
                ).indent(4) ~ "\n" ~
                ');'
            )
        );
    }

    method add-foreigh-key(Match:D $s, Bool:D :$back = False --> Yii2Statement) {
        my ($a, $f, $t, $d, $u) = $s<alias source target fk_on_delete fk_on_update>;
        ($f, $t) = $t, $f if $back;
        my $index_name = self.index-name(S_FK, $a, $f, $t);
        Yii2Statement.new(
            :name("add_$index_name"),
            :code(
                '$this->addForeignKey(' ~ "\n" ~
                (
                    self.string($index_name) ~ ",\n" ~
                    self.table-string($f<table>) ~ ', [' ~
                    $f<columns>.list.map({ self.name-string($_) }).join(', ') ~ "],\n" ~
                    self.table-string($t<table>) ~ ', [' ~
                    $t<columns>.list.map({ self.name-string($_) }).join(', ') ~ "],\n" ~
                    self.fk-action-string($d) ~ ",\n" ~
                    self.fk-action-string($u)
                ).indent(4) ~ "\n" ~
                ');'
            )
        );
    }
    method drop-foreign-key(Match:D $s, Bool:D :$back = False --> Yii2Statement) {
        my ($a, $f, $t) = $s<alias source target>;
        ($f, $t) = $t, $f if $back;
        my $index_name = self.index-name(S_FK, $a, $f, $t);
        Yii2Statement.new(
            :name("drop_$index_name"),
            :code(
                '$this->dropForeignKey(' ~ "\n" ~
                (
                    self.string($index_name) ~ ",\n" ~
                    self.table-string($f<table>)
                ).indent(4) ~ "\n" ~
                ');'
            )
        );
    }
    method index-name(Str $prefix, $alias, *@table-col-refs --> Str) {
        return self.name($alias<name>) if $alias ~~ Match:D;
        my @tables;
        my @columns;
        # $*ERR.say(@table-col-refs);
        for @table-col-refs {
            # $*ERR.say($(:TABLE($_<table>), :COLUMNS($_<columns>)));
            push |.list for @tables, @columns Z $_<table>, $_<columns>;
        }
        # $*ERR.say($(:@tables, :@columns));
        for @tables {
            $_ = self.table($_);
        }
        # $*ERR.say($(:@tables, :@columns).perl);

        my @refs = (@tables Z @columns).flat;

        while @refs {
            with ($prefix, @refs.map({ .list })).flat.join('-') {
                .return if .chars <= MAX_INDEX_LENGTH;
            }
            @refs.pop;
        }
        die "too long index name in any case";
    }

    method rename-table(Match:D $s, Bool:D :$back = False --> Yii2Statement) {
        my ($from_table, $to_table) = $s<table rename_table>;
        $to_table = $to_table<table>;
        ($from_table, $to_table) = $to_table, $from_table if $back;
        Yii2Statement.new(
            :name("rename_{self.table($from_table)}_{self.table($to_table)}"),
            :code(
                '$this->renameTable(' ~
                self.table-string($from_table) ~ ', ' ~
                self.table-string($to_table) ~ ');'
            )
        );
    }

    method alter-column-name(Match:D $s, Bool:D :$back = False --> Yii2Statement) {
        my $table = $s<table>;
        my ($from_name, $to_name) = $s<alter_column><name alter_column_spec>;
        $from_name = self.name($from_name);
        $to_name = self.name($to_name<alter_column_name><name>);
        ($from_name, $to_name) = $to_name, $from_name if $back;
        Yii2Statement.new(
            :name("rename_{self.table($table)}_{$from_name}_{$to_name}"),
            :code(
                '$this->renameColumn(' ~
                self.table-string($table) ~ ', ' ~
                self.string($from_name) ~ ', ' ~
                self.string($to_name) ~ ');'
            )
        );
    }
    method alter-column-type(Match:D $s, Bool:D :$back = False --> Yii2Statement) {
        my $table = $s<table>;
        my ($name, $spec) = $s<alter_column><name alter_column_spec>;
        $name = self.name($name);
        my $type = $spec{$back ?? 'from' !! 'to'};
        Yii2Statement.new(
            :name("alter_{self.table($table)}_$name"),
            :code(
                '$this->alterColumn(' ~ "\n" ~
                (
                    self.table-string($table) ~ ",\n" ~
                    self.string($name) ~ ",\n" ~
                    self.column-type-pos($type)
                ).indent(4) ~ "\n" ~
                ');'
            )
        );
    }

    method data-statement(Match:D $s, Bool:D :$back = False --> Yii2Statement) {
        Yii2Statement.new(
            :name('update')
            :code(
                '// TODO: ' ~
                ($back
                    ?? 'undo that updates'
                    !! 'add some updates'
                )
            ),
        );
    }

    method column-type-pos(Match:D $t --> Str) {
        my ($type, $pos) = $t<type position>;
        $type = self.column-type($type);
        return $type without $pos;
        return $type ~ '->first()' if $pos<pos_first>;
        return $type ~ '->after(' ~ self.name-string($pos<name>) ~ ')';
    }

    method column-type(Match:D $t --> Str) {
        my ($name, $params, $null, $default) = $t<name params null_mark default_value>;
        $name = self.name($name);
        $params = $params
            ?? $params<number>».Str.join(', ')
            !! '';

        %types{$name}:exists or self.throw-unsupported("unknown type `$name`");
        my ($type, $appendix, $defined) = do given %types{$name} {
            when * === True { ($name,) }
            when Str:D { (.self,) }
            when List { .self }
            when Map { @(.self<t a D>) }
            default {
                die "bad type declaration for `$name`";
            }
        };

        my $ret = '$this->' ~ $type ~ '(' ~ $params ~ ')';
        if $defined {
            with $null {
                self.throw-unsupported(
                    "type `$name` (`$type`) is strictly defined so it cannot be NULL"
                );
            }
        }
        else {
            $ret ~= '->notNull()' without $null;
        }
        $ret ~= '->defaultValue(' ~ self.default-value($default) ~ ')' with $default;
        $ret ~= * with $appendix;
        $ret;
    }

    method string(Str $s --> Str) {
        "'" ~ $s.subst(/(<[\\ ']>)/, { "\\$0" }, :g) ~ "'";
    }

    method table-string(Match:D $t --> Str) {
        self.string('{{%' ~ self.table($t) ~ '}}');
    }

    method name-string(Match:D $n --> Str) {
        self.string(self.name($n));
    }

    multi method fk-action-string(Match:D $on) {
        my $action = $on<fk_verb>.hash.keys[0];
        die "unexpected FK action `$action`" unless FK_ACTION{$action}:exists;
        self.string(FK_ACTION{$action});
    }
    multi method fk-action-string(Any:U) {
        self.string(FK_ACTION<fk_restrict>);
    }
}

class Yii2Exporter does MigrationExporter {
    has Str:D      $.indent       is required;
    has IO::Path:D $.path         is required;
    has Str:D      $.class-prefix = 'm%y%m%d_%H%M%S_';
    has Int:D      $.dir-chmod    = 0o775;

    has DateTime $!time;

    submethod TWEAK() {
        my %formats = (
            '%' => ['%%'  , Nil],
            Y   => ['%04d', { .year       }],
            y   => ['%02d', { .year % 100 }],
            'm' => ['%02d', { .month      }],
            d   => ['%02d', { .day        }],
            H   => ['%02d', { .hour       }],
            M   => ['%02d', { .minute     }],
            'S' => ['%02d', { .second     }],
        );
        my @params-getters;
        my sub pass(Str:D $char) {
            with %formats{$char} {
                my ($placeholder, $getter) = @($_);
                @params-getters.push($getter)   with $getter;
                return $placeholder;
            }
            abort "unknown placholder `%{$char}`";
        }
        my Str $format = $!class-prefix.subst(/ '%' (.) /, { pass($0.Str) }, :g);

        $!time = DateTime.now(
            timezone  => 0,
            formatter => {
                sprintf $format, |@params-getters.map({ $^c(.self) });
            },
        );
    }

    method export(Yii2Migration:D $migration) {
        my Str:D $prefix = $!time.Str;
        $prefix.=subst(/ :i <-[ a..z \d / ]>+ /, '_', :g);
        $prefix.=subst(/ ^ '/'            /, '');
        $prefix.=subst(/   '/' <( '/'+ )> /, '', :g);
        $prefix.=subst(/   '/' $          /, '');

        my Str:D $ns-class = $prefix ~ $migration.up.name.subst('-', '_', :g);
        my Str:D $class    = $ns-class.IO.basename;

        my IO::Path $filename = $!path.add($ns-class ~ ".php");
        abort "file already exists - `$filename`" if $filename.e;

        given $filename.parent {
            when .e {
                .d or abort "path `{.self}` exists and is not a directory";
            }
            default {
                .mkdir($!dir-chmod);
            }
        }

        my $body = '';
        $body ~= "// $_".trim ~ "\n" for $migration.header;
        $body ~= "\n" if $migration.header.elems;
        $body ~=
            "public function up()\n" ~
            "\{\n" ~
            $migration.up.code.indent(4) ~ "\n" ~
            "}\n\n" ~
            "public function down()\n" ~
            "\{\n" ~
            $migration.down.code.indent(4) ~ "\n" ~
            '}';

        my $code = '<?php' ~ "\n\n" ~ 'use yii\db\Migration;' ~ "\n\n" ~
            "class $class extends Migration\n" ~
            "\{\n" ~
            $body.indent(4) ~ "\n" ~
            "}\n";

        unless ' ' x 4 eq $migration.indent {
            $code.=subst(/^^(' ' ** 4)+/, { $!indent x $0.elems }, :g);
        }

        $filename.spurt($code, :createonly)
            or X::App::IO.new(pyload => "cannot create file - `$filename`");

        $!time.=later(:5second);
    }
}

sub transform(IO::Handle :$input, TransformFormat :$format, MigrationExporter :$exporter) {
    put "$PROJECT_NAME ver. $PROJECT_VER"   if IS_I;
    put "Interactive mode"                  if IS_I;
    print '> '                              if IS_I;

    my @migrations;
    my Int $line_number = 0;

    # https://rt.perl.org/Public/Bug/Display.html?id=132076
    # last/next inside CATCH does not work ever - neither anonymouse nor labeled
    #
    # `IO::Handle.lines` reads input lazily. Label for the loop
    # could not be found - an exception cause some corruptions.
    #
    # So, here is `Bool $goto-next` to solve CATCH blocks.
    for $input.lines -> $line {
        NEXT {
            print '> '      if IS_I;
        }
        LAST {
            put '(EOF)'     if IS_I;
        }

        ++$line_number;
        next unless $line.trim;
        my $statement;
        my $goto-next = False;
        try {
            $statement = MigrationSource.parse($line, rule => 'statement');

            CATCH {
                when X::App::MatchFail {
                    if IS_I {
                        put "Syntax: $_";
                        # next;
                        $goto-next = True;
                    }
                    else {
                        abort "syntax: $_ - at line $line_number";
                    }
                }
                when X::App::Runtime {
                    if IS_I {
                        put "{.^name}: $_";
                        # next;
                        $goto-next = True;
                    }
                    else {
                        abort "{.^name}: $_ - at line $line_number";
                    }
                }
            }
        }
        next if $goto-next;
        unless $statement {
            if IS_I {
                put 'Syntax mismatch';
                next;
            }
            abort "cannot match at line $line_number\n";
        }

        my $migration;
        try {
            $migration = {
                migration => $format.make-migration($statement),
                line => $line_number,
            };

            CATCH {
                when X::App::Runtime {
                    if IS_I {
                        put "{.^name}: $_";
                        # next;
                        $goto-next = True;
                    }
                    else {
                        abort "{.^name}: $_ - at line $line_number";
                    }
                }
            }
        }
        next if $goto-next;

        if IS_I {
            try {
                $exporter.export($migration<migration>);
                CATCH {
                    when X::App::Runtime {
                        put "{.^name}: $_";
                        # next;
                        # nothing to skip
                    }
                }
            }
        }
        else {
            @migrations.push($migration);
        }
    }

    for @migrations -> $item {
        try {
            $exporter.export($item<migration>);
            CATCH {
                when X::App::Runtime {
                    abort "{.^name}: $_ - at line $item<line>";
                }
            }
        }
    }
}

my constant DEFAULT_INDENT = ' ' x 4;

my %*SUB-MAIN-OPTS = (
    :named-anywhere,
);

multi sub MAIN('yii2', 'list-types') {
    .put for Yii2Format.data-types.sort;
}

multi sub MAIN('yii2',
    Str:D :$path         = './migrations',
    Str:D :$indent       = DEFAULT_INDENT,
    Str:D :$class-prefix = 'm%y%m%d_%H%M%S_',
    Str:D :$dir-chmod    = '775',
) {
    my $path_io = $path.IO;
    with $path_io {
        unless .e && .d {
            abort "given path either does not exist or is not a directory - {.self}";
        }
    }

    transform(
        input    => $*IN,
        format   => Yii2Format.new,
        exporter => Yii2Exporter.new(
            :path($path_io),
            :$indent,
            :$class-prefix,
            :dir-chmod(:8($dir-chmod))
        ),
    );
}

multi sub MAIN() {
    transform(
        input    => $*IN,
        format   => Yii2Format.new,
        exporter => DebugExporter.new,
    );
}

sub get-usage() {
    Q:c:to/_END/;
    Usage:
        {$*PROGRAM-NAME}

        {$*PROGRAM-NAME} yii2 [<options>]
        {$*PROGRAM-NAME} yii2 list-types

        {$*PROGRAM-NAME} man
    _END
}

multi sub MAIN('man') {
    print Q:c:to/_END/;
    {$PROJECT_NAME} v{$PROJECT_VER}

    {get-usage()}
    Description
        Generates migrations from short stupid weird script.

        Without arguments reads source script from the input and writes result
        in debug style to output. When both input and output are terminal then
        interactive mode will be enabled.

        `yii2` subset toggles Yii2 migrations to be generated into given directory.

    Options

        **yii2**

        --class-prefix=<format>
            Format to generate path and filename prefix for migrations under
            the `--path` directory. Default format `m%y%m%d_%H%M%S_` will
            produce classes names like so:

                m170829_150305_create_user
                m170829_150310_add_idx_user_mail
                ...

            Supported placeholders from `date(1)` are: %Y %y %m %d %H %M %S.

            Format can contain `/` to create subdirectories.

        --dir-chmod=<mode>
            Permissions for subdirectories produced by `--class-prefix`
            with `/` in format. Octal number. Default is `775`.

        --indent=string
            One level indention string. Will be used literally in generated
            result. Default is four spaces.
            To use TAB follow instructions for you shell. For example in Bash
            you can use C-style string: $'\t' .

        --path=<path>
            Base path to store generated migrations. Path must to exist. Default
            is `./migrations` .

    _END
}

sub USAGE() {
    print get-usage();
}
