#!/usr/bin/env perl6

use v6.c;

my constant $PROJECT_NAME = 'Lazy Migration Generator';
my constant $PROJECT_VER  = '0.0.2';

class X::App::MatchFail is X::AdHoc {}
class X::App::Runtime is X::AdHoc {}
class X::App::Unsupported is X::App::Runtime {}
class X::App::IO is X::App::Runtime {}

class X::App::Abort is X::AdHoc {
    multi method gist(X::App::Abort:D:) { $.payload }
}

my \IS_I = INIT { $*IN.t && $*OUT.t };

sub abort(Str:D $message) {
    die X::App::Abort.new(payload => $message);
}

grammar MigrationSource {
    token ws { <!ww> \h* }

    token num-sign { <[- +]> }
    token num-int { 0 | <[1..9]> \d* }
    token num-frac { '.' \d+ }
    token num-exp { :i e <.num-sign>? \d+ }
    token number { <.num-sign>? <.num-int> <.num-frac>? <.num-exp>? }

    token string-content { [ <-[' \\]>+ | \\ . ]* }
    token string-content-with-end { <string-content> ~ \' <?> }
    token string { \' ~ <string-content-with-end> <?> }

    token value-keyword { :i << [ TRUE | FALSE | NULL ] >> }

    token name-word {
        :i
        <!before <[ - \d ]> >
        [ <[ _ a..z \d ]>+ | \\ . ]+
    }
    token name { <.name-word>+ % '-'+ }

    proto token value {*}
    token value:sym<string> { <string> }
    token value:sym<number> { <number> }
    token value:sym<value-keyword> { <value-keyword> }

    rule default-value { ['=' <!before '>'>] ~ <value> <?> }
    rule numbers-list { [<number> ]* % [',' ] }
    rule params-list { <numbers-list> ~ ')' <?> }
    rule params { '(' ~ <params-list> <?> }
    token null-mark { '?' }
    rule type {
        [':' ~ <name> <?>]
        <params>?
        <null-mark>?
        <default-value>?
    }

    rule column-definition { <name> ~ <type> <?> }

    rule column-definition-list { [<column-definition> ]+ % [',' ] }
    rule columns-definitions-end { <column-definition-list> ~ ')' <?> }
    rule create-table-body { '(' ~ <columns-definitions-end> <?> }

    proto rule position {*}
    rule position:sym<first> { '^' }
    rule position:sym<after> { '>' ~ <name> <?> }

    rule alter-column-type { <type> <position>? }

    token alias { '@' ~ <name> <?> }
    token table { '%' ~ <name> <?> }

    rule alter-column-type-to { <alter-column-type> ~ '=>' <?> }
    proto rule alter-column-spec {*}
    rule alter-column-spec:sym<name> { '=>' ~ <name> <?> }
    rule alter-column-spec:sym<type> { <alter-column-type-to> ~ <alter-column-type> <?> }
    rule alter-column { <name> ~ <alter-column-spec> <?> }
    rule rename-table { '=>' ~ <table> <?> }

    rule names-list { [<name> ]+ % [',' ] }
    rule columns-ref-list-end { <names-list> ~ ')' <?> }
    proto rule columns-ref {*}
    rule columns-ref:<dot> { '.' ~ <name> <?> }
    rule columns-ref:<list> { '(' ~ <columns-ref-list-end> <?> }
    rule table-columns-ref { <table> ~ <columns-ref> <?> }

    proto token fk-verb {*}
    token fk-verb:sym<restrict> { '!' }
    token fk-verb:sym<cascade> { '>' }
    token fk-verb:sym<set-null> { '?' }
    token fk-on-delete { '~' ~ <fk-verb> <?> }
    token fk-on-update { '*' ~ <fk-verb> <?> }
    rule fk-target { '=>' ~ <table-columns-ref> <?> }
    rule fk-map { <table-columns-ref> ~ <fk-target> <?> }
    rule fk-spec { <alias>? ~ <fk-map> <?> }
    rule fk-statement {
        [:i<<FK>>] ~ <fk-spec> <?>
        [
            <fk-on-delete> <fk-on-update>?
            | <fk-on-update> <fk-on-delete>?
        ]?
    }

    token index-type { :i << [I | U | PK] >> }
    rule key-spec { <alias>? ~ <table-columns-ref> <?> }
    rule key-statement { <index-type> ~ <key-spec> <?> }

    rule add-column-spec { <name> ~ <alter-column-type> <?> }
    rule add-column-body { '.' ~ <add-column-spec> <?> }
    proto rule table-ddl-spec {*}
    rule table-ddl-spec:sym<create> { <create-table-body> }
    rule table-ddl-spec:sym<add-col> { <add-column-body> }
    rule table-ddl-statement { <table> ~ <table-ddl-spec> <?> }

    proto rule ddl-statement {*}
    rule ddl-statement:<table> { <table-ddl-statement> }
    rule ddl-statement:<key> { <key-statement> }
    rule ddl-statement:<fk> { <fk-statement> }

    rule create-statement { '+' ~ <ddl-statement> <?> }
    rule drop-statement { '-' ~ <ddl-statement> <?> }

    rule data-statement { '=' }

    proto rule alter-statement-spec {*}
    rule alter-statement-spec:sym<rename-table> { <rename-table> }
    rule alter-statement-spec:sym<alter-column> { '.' ~ <alter-column> <?> }
    rule alter-statement-body { <table> ~ <alter-statement-spec> <?> }
    rule alter-statement { '*' ~ <alter-statement-body> <?> }

    rule comment-line { '#' \N* }

    proto rule statement-body {*}
    rule statement-body:sym<create> { <create-statement> }
    rule statement-body:sym<drop> { <drop-statement> }
    rule statement-body:sym<alter> { <alter-statement> }
    rule statement-body:sym<data> { <data-statement> }
    rule statement-body:sym<comment> { <comment-line> }

    rule statement-start { ^^ ~ <statement-body> <?> }
    rule TOP { <statement-start> ~ $$ <?> }

    my %goal-display = (
        add-column-spec         => '<name>',
        alter-column            => '<name>',
        alter-column-spec       => '`:` or `=>`',
        alter-column-type       => '`:`',
        alter-statement-body    => '<table>',
        alter-statement-spec    => '`.` or `=>`',
        columns-definitions-end => '<name>',
        columns-ref             => '`.` or `(`',
        columns-ref-list-end    => '<name>',
        ddl-statement           => '<table> , `PK` , `U` , `I` or `FK`',
        fk-map                  => '<table>',
        fk-target               => '`=>`',
        fk-verb                 => '`!` , `>` or `?`',
        # name                    => '',
        # table                   => '`%table`',
        table-columns-ref       => '<table>',
        table-ddl-spec          => '`(` or `.`',
        type                    => '`:`',
        # value                   => '',
    );

    method FAILGOAL($goal) {
        my constant CONTEXT = 10;
        my $expected = do given $goal.trim {
            when '$$'                               { 'EOL'  }
            when "\\'"                              { "<'>"  }
            when / \' ( <-[ ' \\ ]>+ ) \' /         { "`$0`" }
            when / '<' '.'? ( <[ a..z - ]>+ ) '>' / { %goal-display{$0} || .self }
            default                                 { .self  }
        }

        my $after = self.target.substr((self.pos - CONTEXT max 0) ..^ self.pos);
        $after = $after
            ?? ' after `' ~ (self.pos > CONTEXT ?? '...' !! '') ~ $after ~ '`'
            !! "";
        my $near = self.pos < self.target.chars
            ?? 'near `'
                ~ self.target.substr(self.pos, CONTEXT)
                ~ (self.pos < self.target.chars - CONTEXT ?? '...' !! '')
                ~ '`'
            !! 'instead of EOL';
        die X::App::MatchFail.new(
            payload => "expected {$expected}{$after} {$near} at position {self.pos}"
        );
    }
}

my constant POS_FIRST = 'first';
my constant POS_AFTER = 'after';

my constant ALTER_NAME = 'name';
my constant ALTER_TYPE = 'type';

my constant FK_RESTRICT = 'restrict';
my constant FK_CASCADE  = 'cascade';
my constant FK_SET_NULL = 'set-null';

my constant ST_EMPTY        = 'empty';
my constant ST_CREATE_TABLE = 'create-table';
my constant ST_ADD_COLUMN   = 'add-column';
my constant ST_PRIMARY      = 'primary';
my constant ST_UNIQUE       = 'unique';
my constant ST_INDEX        = 'index';
my constant ST_FK           = 'foreign-key';
my constant ST_DATA         = 'data';
my constant ST_RENAME_TABLE = 'rename-table';
my constant ST_ALTER_COLUMN = 'alter-column';

class App::Number {
    has Str:D $.source is required;

    multi method gist(App::Number: --> Str) {
        "{self.^name}({$!source})";
    }
}

class MigrationSourceActions {
    my %keyword-value = (
        TRUE  => True,
        FALSE => False,
        NULL  => Nil,
    );
    my %key-type = (
        PK => ST_PRIMARY,
        U  => ST_UNIQUE,
        I  => ST_INDEX,
    );

    method !unescape ($str) { $str.subst(/ \\ (.) /, { $0 }, :g) }

    method number ($/) { make App::Number.new(source => $/.Str) }

    method string-content ($/) { make self!unescape($/.Str) }
    method string-content-with-end ($/) { make $<string-content>.made }
    method string ($/) { make $<string-content-with-end>.made }

    method value-keyword ($/) { make $/.Str.uc }

    method name ($/) { make self!unescape($/.Str) }

    method value:sym<string> ($/) { make $<string>.made }
    method value:sym<number> ($/) { make $<number>.made }
    method value:sym<value-keyword> ($/) { make %keyword-value{$<value-keyword>.made} }

    method default-value ($/) { make $<value>.made }
    method numbers-list ($/) { make $<number>».made }
    method params-list ($/) { make $<numbers-list>.made }
    method params ($/) { make $<params-list>.made }
    method type ($/) {
        make {
            name          => $<name>.made,
            params        => $<params>.made // [],
            null          => $<null-mark>.Bool,
            default       => $<default-value>.Bool,
            default-value => $<default-value>.made,
        };
    }

    method column-definition ($/) {
        make {
            name => $<name>.made,
            type => $<type>.made,
        };
    }

    method column-definition-list ($/) { make $<column-definition>».made }
    method columns-definitions-end ($/) { make $<column-definition-list>.made }
    method create-table-body ($/) { make $<columns-definitions-end>.made }

    method position:sym<first> ($/) { make {pos => POS_FIRST} }
    method position:sym<after> ($/) { make {pos => POS_AFTER, name => $<name>.made} }

    method alter-column-type ($/) {
        make {
            type     => $<type>.made,
            position => $<position>.made,
        }
    }

    method alias ($/) { make $<name>.made }
    method table ($/) { make $<name>.made }

    method alter-column-type-to ($/) { make $<alter-column-type>.made }
    method alter-column-spec:sym<name> ($/) {
        make {
            alt => ALTER_NAME,
            to  => $<name>.made,
        };
    }
    method alter-column-spec:sym<type> ($/) {
        make {
            alt  => ALTER_TYPE,
            from => $<alter-column-type-to>.made,
            to   => $<alter-column-type>.made,
        };
    }
    method alter-column ($/) {
        make {
            name => $<name>.made,
            $<alter-column-spec>.made.kv,
        };
    }
    method rename-table ($/) { make $<table>.made }

    method names-list ($/) { make $<name>».made }
    method columns-ref-list-end ($/) { make $<names-list>.made }
    method columns-ref:<dot> ($/) { make [$<name>.made] }
    method columns-ref:<list> ($/) { make $<columns-ref-list-end>.made }
    method table-columns-ref ($/) {
        make {
            table   => $<table>.made,
            columns => $<columns-ref>.made,
        };
    }

    method fk-verb:sym<restrict> ($/) { make FK_RESTRICT }
    method fk-verb:sym<cascade> ($/)  { make FK_CASCADE  }
    method fk-verb:sym<set-null> ($/) { make FK_SET_NULL }
    method fk-on-delete ($/) { make { delete => $<fk-verb>.made } }
    method fk-on-update ($/) { make { update => $<fk-verb>.made } }
    method fk-target ($/) { make $<table-columns-ref>.made }
    method fk-map ($/) {
        make {
            child  => $<table-columns-ref>.made,
            parent => $<fk-target>.made,
        };
    }
    method fk-spec ($/) {
        make {
            alias => $<alias>.made,
            $<fk-map>.made.kv,
        };
    }
    method fk-statement ($/) {
        make {
            delete => FK_RESTRICT,
            update => FK_RESTRICT,
            $<fk-spec>.made.kv,
            $<fk-on-delete>.made.kv,
            $<fk-on-update>.made.kv,
        };
    }

    method index-type ($/) { make %key-type{$/.Str.uc} }
    method key-spec ($/) {
        make {
            alias => $<alias>.made,
            $<table-columns-ref>.made.kv,
        };
    }
    method key-statement ($/) {
        make {
            statement => $<index-type>.made,
            $<key-spec>.made.kv,
        };
    }

    method add-column-spec ($/) {
        make {
            name => $<name>.made,
            $<alter-column-type>.made.kv,
        };
    }
    method add-column-body ($/) { make $<add-column-spec>.made }
    method table-ddl-spec:sym<create> ($/) {
        make {
            statement => ST_CREATE_TABLE,
            columns   => $<create-table-body>.made,
        };
    }
    method table-ddl-spec:sym<add-col> ($/) {
        make {
            statement => ST_ADD_COLUMN,
            $<add-column-body>.made.kv,
        };
    }
    method table-ddl-statement ($/) {
        make {
            table => $<table>.made,
            $<table-ddl-spec>.made.kv,
        };
    }

    method ddl-statement:<table> ($/) { make $<table-ddl-statement>.made }
    method ddl-statement:<key> ($/) { make $<key-statement>.made }
    method ddl-statement:<fk> ($/) {
        make {
            statement => ST_FK,
            $<fk-statement>.made.kv,
        };
    }

    method create-statement ($/) {
        make {
            create => True,
            $<ddl-statement>.made.kv,
        };
    }
    method drop-statement ($/) {
        make {
            drop => True,
            $<ddl-statement>.made.kv,
        };
    }

    method data-statement ($/) { make { statement => ST_DATA } }

    method alter-statement-spec:sym<rename-table> ($/) {
        make {
            statement => ST_RENAME_TABLE,
            to   => $<rename-table>.made,
        };
    }
    method alter-statement-spec:sym<alter-column> ($/) {
        make {
            statement => ST_ALTER_COLUMN,
            $<alter-column>.made.kv,
        };
    }
    method alter-statement-body ($/) {
        make {
            table => $<table>.made,
            $<alter-statement-spec>.made.kv,
        };
    }
    method alter-statement ($/) { make $<alter-statement-body>.made }

    method comment-line ($/) { make { statement => ST_EMPTY } }

    method statement-body:sym<create>  ($/) { make $<create-statement>.made }
    method statement-body:sym<drop>    ($/) { make $<drop-statement>.made }
    method statement-body:sym<alter>   ($/) { make $<alter-statement>.made }
    method statement-body:sym<data>    ($/) { make $<data-statement>.made }
    method statement-body:sym<comment> ($/) { make $<comment-line>.made }

    method statement-start ($/) { make $<statement-body>.made }
    method TOP ($/) { make $<statement-start>.made }
}

class Statement {
    has Str:D  $.name   = '';
    has Str:D  $.code   = '';
    has Bool:D $.is-dml = False;

    submethod TWEAK() {
        $!name = self.filter-name($!name);
    }

    multi method gist(Statement: --> Str) {
        "`$!name` is-dml={$!is-dml} ⟨\n" ~
        $!code.indent(4) ~ "\n" ~
        "⟩";
    }

    method filter-name(Str:D $name --> Str:D) { $name }
}

class Migration {
    has Match:D     $.source is required;
    has Str:D       @.header;
    has Statement:D $.up     is required;
    has Statement:D $.down   is required;

    method BUILDALL(|) {
        @!header.unshift(
            "Generated with $PROJECT_NAME",
        );

        callsame;

        @!header.push(
            "",
            "Source:",
            "    {$!source.trim}",
        );

        self;
    }

    multi method gist(Migration: --> Str) {
        '$> ' ~ self.up.name ~ "\n" ~
        @!header.map({
            "> $_".trim.indent(4) ~ "\n"
        }).join ~
        (UP => self.up, DOWN => self.down).map({
            (
                .key ~ ":\n" ~
                .value.gist.indent(4)
            ).indent(4) ~ "\n"
        }).join ~
        '.';
    }
}

role TransformFormat {
    # Export matched statement to complete migration code
    method make-migration(Match:D $s --> Migration) {
        Migration.new(
            source => $s,
            up     => self.statement($s),
            down   => self.statement($s, :back),
        );
    }

    method create-table($s --> Statement) {...}
    method drop-table  ($s --> Statement) {...}

    method add-column ($s --> Statement) {...}
    method drop-column($s --> Statement) {...}

    method add-primary-key ($s --> Statement) {...}
    method drop-primary-key($s --> Statement) {...}

    method add-unique-key ($s --> Statement) {...}
    method drop-unique-key($s --> Statement) {...}

    method add-index ($s --> Statement) {...}
    method drop-index($s --> Statement) {...}

    method add-foreigh-key ($s, Bool:D :$back = False --> Statement) {...}
    method drop-foreign-key($s, Bool:D :$back = False --> Statement) {...}

    method rename-table($s, Bool:D :$back = False --> Statement) {...}

    method alter-column-name($s, Bool:D :$back = False --> Statement) {...}
    method alter-column-type($s, Bool:D :$back = False --> Statement) {...}

    method data-statement($s, Bool:D :$back = False --> Statement) {...}

    method statement(Match:D $s, Bool:D :$back = False --> Statement) {
        my $m = $s.made;
        given $m<statement> {
            when ST_CREATE_TABLE {
                return self.drop-table($m)          if $back ?^ $m<drop>;
                return self.create-table($m);
            }
            when ST_ADD_COLUMN {
                return self.drop-column($m)         if $back ?^ $m<drop>;
                return self.add-column($m);
            }
            when ST_PRIMARY {
                return self.drop-primary-key($m)    if $back ?^ $m<drop>;
                return self.add-primary-key($m);
            }
            when ST_UNIQUE {
                return self.drop-unique-key($m)     if $back ?^ $m<drop>;
                return self.add-unique-key($m);
            }
            when ST_INDEX {
                return self.drop-index($m)          if $back ?^ $m<drop>;
                return self.add-index($m);
            }
            when ST_FK {
                return self.drop-foreign-key($m)    if $back ?^ $m<drop>;
                return self.add-foreigh-key($m);
            }
            when ST_RENAME_TABLE {
                return self.rename-table($m, :$back);
            }
            when ST_ALTER_COLUMN {
                return self.alter-column-name($m, :$back)   if ALTER_NAME eq $m<alt>;
                return self.alter-column-type($m, :$back);
            }
            when ST_DATA {
                return self.data-statement($m, :$back);
            }
            default {
                die "expected statement type `{.self}`";
            }
        }
    }

    method default-value($value --> Str) {
        given $value {
            when Bool {
                return self.boolean(.self);
            }
            when App::Number {
                return self.number(.self.source);
            }
            when Str {
                return self.string(.self);
            }
            when Any:U {
                return self.null-value;
            }
            default {
                die "unexpected data type {.WHAT}";
            }
        }
    }

    method string($s --> Str) { $s }
    method number($n --> Str) { $n }
    method boolean($b --> Str) { ~$b }
    method null-value(--> Str) { 'NULL' }

    method throw-unsupported(Str:D $message) {
        die X::App::Unsupported.new(payload => $message);
    }
}

role MigrationExporter {
    method export(Migration:D $migration --> Bool) { ... }
}

class DebugExporter does MigrationExporter {
    has IO::Handle $!to = $*OUT;

    method export(Migration:D $migration --> Bool) {
        $!to.say($migration);
    }
}

class Yii2Statement is Statement {
    method filter-name(Str:D $name --> Str:D) {
        $name
            .subst(/ :i <-[ a..z \d ]>+ /, '_', :g)
            .subst(/ ^ _+ || _+ $ /, '', :g)
            || 'noname';
    }
}

class Yii2Migration is Migration {
    has Str:D $.indent = '';

    method BUILDALL(|) {
        self.header.unshift("Format: Yii2");

        callsame;
        self;
    }
}

class Yii2Format does TransformFormat {
    my constant UNSIGNED         = '->unsigned()';
    my constant MAX_INDEX_LENGTH = 64;

    my constant %types = {
        primary      => {:t<primaryKey>,    :D},
        uprimary     => {:t<primaryKey>,    :D, :a(UNSIGNED)},
        primary-big  => {:t<bigPrimaryKey>, :D},
        uprimary-big => {:t<bigPrimaryKey>, :D, :a(UNSIGNED)},
        char         => True,
        string       => True,
        text         => True,
        int16        => 'smallInteger',
        uint16       => ['smallInteger', UNSIGNED],
        int          => 'integer',
        uint         => ['integer', UNSIGNED],
        bigint       => 'bigInteger',
        int64        => 'bigInteger',
        uint64       => ['bigInteger', UNSIGNED],
        float        => True,
        double       => True,
        decimal      => True,
        date         => True,
        datetime     => 'dateTime',
        time         => True,
        timestamp    => True,
        binary       => True,
        bool         => 'boolean',
        money        => True,
    };

    my constant FK_ACTION = {
        (FK_RESTRICT) => 'RESTRICT',
        (FK_CASCADE)  => 'CASCADE',
        (FK_SET_NULL) => 'SET NULL',
    };

    my constant S_FK = 'fk';
    my constant S_PK = 'pk';
    my constant S_IDX = 'idx';

    method data-types(--> Iterable) {
        %types.keys;
    }

    method make-migration(Match:D $s --> Migration) {
        Yii2Migration.new(
            source => $s,
            up     => self.statement($s),
            down   => self.statement($s, :back),
        );
    }

    method create-table($s --> Yii2Statement) {
        my ($table, $columns) = $s<table columns>;
        Yii2Statement.new(
            :name("create_{$table}"),
            :code(
                '$tableOptions = null;' ~ "\n" ~
                q[if ($this->db->driverName === 'mysql') {] ~ "\n" ~
                (
                    '// https://stackoverflow.com/q/766809' ~ "\n" ~
                    q[$tableOptions = 'CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE=InnoDB';]
                ).indent(4) ~ "\n" ~
                "}\n" ~
                "\n" ~
                '$this->createTable(' ~ self.table-string($table) ~ ", [\n" ~
                @($columns).map({
                    my ($name, $type) = .<name type>;
                    self.string($name) ~ ' => ' ~ self.column-type($type) ~ ',';
                }).join("\n").indent(4) ~ "\n" ~
                '], $tableOptions);'
            ),
        );
    }
    method drop-table($s --> Yii2Statement) {
        my ($table) = $s<table>;
        Yii2Statement.new(
            :name("drop_{$table}"),
            :code('$this->dropTable(' ~ self.table-string($table) ~ ');')
        );
    }

    method add-column($s --> Yii2Statement) {
        my ($table, $column, $type, $pos) = $s<table name type position>;
        Yii2Statement.new(
            :name("add_{$table}_{$column}"),
            :code(
                '$this->addColumn(' ~ "\n" ~
                (
                    self.table-string($table) ~ ",\n" ~
                    self.string($column) ~ ",\n" ~
                    self.column-type-pos($type, $pos)
                ).indent(4) ~ "\n" ~
                ');'
            )
        );
    }
    method drop-column($s --> Yii2Statement) {
        my ($table, $column) = $s<table name>;
        Yii2Statement.new(
            :name("drop_{$table}_{$column}"),
            :code(
                '$this->dropColumn(' ~
                self.table-string($table) ~ ', ' ~
                self.string($column) ~
                ');'
            )
        );
    }

    method add-primary-key($s --> Yii2Statement) {
        self!index-common($s, 'add_', 'addPrimaryKey', S_PK, :cols);
    }
    method drop-primary-key($s --> Yii2Statement) {
        self!index-common($s, 'drop_', 'dropPrimaryKey', S_PK);
    }

    method add-unique-key($s --> Yii2Statement) {
        self!index-common($s, 'add_', 'createIndex', S_IDX, :cols, :tag<true>);
    }
    method drop-unique-key($s --> Yii2Statement) {
        self!index-common($s, 'drop_', 'dropIndex', S_IDX);
    }

    method add-index($s --> Yii2Statement) {
        self!index-common($s, 'add_', 'createIndex', S_IDX, :cols, :tag<false>);
    }
    method drop-index($s --> Yii2Statement) {
        self!index-common($s, 'drop_', 'dropIndex', S_IDX);
    }

    method !index-common($s, Str $namePrefix, Str $method, Str $prefix, Bool:D :$cols = False, Str :$tag --> Yii2Statement) {
        my ($alias, $table, $columns) = $s<alias table columns>;
        my $index_name = self.index-name($prefix, $alias, $s);
        Yii2Statement.new(
            :name($namePrefix ~ $index_name),
            :code(
                '$this->' ~ $method ~ "(\n" ~
                (
                    self.string($index_name) ~ ",\n" ~
                    self.table-string($table) ~
                    ($cols
                        ?? ",\n[" ~
                        @$columns.map({
                            self.string($_)
                        }).join(', ') ~ ']'
                        !! ''
                    ) ~
                    ($tag
                        ?? ",\n$tag"
                        !! ''
                    )
                ).indent(4) ~ "\n" ~
                ');'
            )
        );
    }

    method add-foreigh-key($s, Bool:D :$back = False --> Yii2Statement) {
        my ($a, $f, $t, $d, $u) = $s<alias child parent delete update>;
        ($f, $t) = $t, $f if $back;
        my $index_name = self.index-name(S_FK, $a, $f, $t);
        Yii2Statement.new(
            :name("add_$index_name"),
            :code(
                '$this->addForeignKey(' ~ "\n" ~
                (
                    self.string($index_name) ~ ",\n" ~
                    self.table-string($f<table>) ~ ', [' ~
                    @($f<columns>).map({ self.string($_) }).join(', ') ~
                    "],\n" ~
                    self.table-string($t<table>) ~ ', [' ~
                    @($t<columns>).map({ self.string($_) }).join(', ') ~
                    "],\n" ~
                    self.string(FK_ACTION{$d}) ~ ",\n" ~
                    self.string(FK_ACTION{$u})
                ).indent(4) ~ "\n" ~
                ');'
            )
        );
    }
    method drop-foreign-key($s, Bool:D :$back = False --> Yii2Statement) {
        my ($a, $f, $t) = $s<alias child parent>;
        ($f, $t) = $t, $f if $back;
        my $index_name = self.index-name(S_FK, $a, $f, $t);
        Yii2Statement.new(
            :name("drop_$index_name"),
            :code(
                '$this->dropForeignKey(' ~ "\n" ~
                (
                    self.string($index_name) ~ ",\n" ~
                    self.table-string($f<table>)
                ).indent(4) ~ "\n" ~
                ');'
            )
        );
    }
    method index-name(Str $prefix, $alias, *@table-col-refs --> Str) {
        with $alias {
            .return if .chars <= MAX_INDEX_LENGTH;
            self.throw-unsupported("too long index name given with alias");
        }

        my @tables;
        my @columns;
        # note @table-col-refs;
        for @table-col-refs {
            # $*ERR.say($(:TABLE($_<table>), :COLUMNS($_<columns>)));
            push |.list for @tables, @columns Z $_<table>, $_<columns>;
        }
        # note $(:@tables, :@columns);
        # note $(:@tables, :@columns).perl;

        my @refs = (@tables Z @columns».list).flat;
        # note $(@refs).perl;

        while @refs {
            with ($prefix, @refs).flat.join('-') {
                .return if .chars <= MAX_INDEX_LENGTH;
            }
            @refs.pop;
        }
        self.throw-unsupported("too long index name in any case");
    }

    method rename-table($s, Bool:D :$back = False --> Yii2Statement) {
        my ($from_table, $to_table) = $s<table to>;
        ($from_table, $to_table) = $to_table, $from_table if $back;
        Yii2Statement.new(
            :name("rename_{$from_table}_{$to_table}"),
            :code(
                '$this->renameTable(' ~
                self.table-string($from_table) ~ ', ' ~
                self.table-string($to_table) ~ ');'
            )
        );
    }

    method alter-column-name($s, Bool:D :$back = False --> Yii2Statement) {
        my ($table, $from_name, $to_name) = $s<table name to>;
        ($from_name, $to_name) = $to_name, $from_name if $back;
        Yii2Statement.new(
            :name("rename_{$table}_{$from_name}_{$to_name}"),
            :code(
                '$this->renameColumn(' ~
                self.table-string($table) ~ ', ' ~
                self.string($from_name) ~ ', ' ~
                self.string($to_name) ~ ');'
            )
        );
    }
    method alter-column-type($s, Bool:D :$back = False --> Yii2Statement) {
        my ($table, $name) = $s<table name>;
        my ($type, $pos) = ($back ?? $s<from> !! $s<to>)<type position>;
        Yii2Statement.new(
            :name("alter_{$table}_$name"),
            :code(
                '$this->alterColumn(' ~ "\n" ~
                (
                    self.table-string($table) ~ ",\n" ~
                    self.string($name) ~ ",\n" ~
                    self.column-type-pos($type, $pos)
                ).indent(4) ~ "\n" ~
                ');'
            )
        );
    }

    method data-statement($s, Bool:D :$back = False --> Yii2Statement) {
        Yii2Statement.new(
            :name('update')
            :code(
                '// TODO: ' ~
                ($back
                    ?? 'undo that updates'
                    !! 'add some updates'
                )
            ),
            :is-dml,
        );
    }

    method column-type-pos($t, $pos --> Str) {
        my $type = self.column-type($t);
        return $type without $pos;
        return $type ~ '->first()' if POS_FIRST eq $pos<pos>;
        return $type ~ '->after(' ~ self.string($pos<name>) ~ ')';
    }

    method column-type($t --> Str) {
        my ($name, $params, $null, $has-default, $default) = $t<name params null default default-value>;
        my $params-joined = @($params)».source.join(', ');

        %types{$name}:exists or self.throw-unsupported("unknown type `$name`");
        my ($type, $appendix, $defined) = do given %types{$name} {
            when * === True { ($name,) }
            when Str:D { (.self,) }
            when List { .self }
            when Map { @(.self<t a D>) }
            default {
                die "bad type declaration for `$name`";
            }
        };

        my $ret = '$this->' ~ $type ~ '(' ~ $params-joined ~ ')';
        if $defined {
            if $null {
                self.throw-unsupported(
                    "type `$name` (`$type`) is strictly defined so it cannot be NULL"
                );
            }
        }
        else {
            $ret ~= '->notNull()' unless $null;
        }
        $ret ~= '->defaultValue(' ~ self.default-value($default) ~ ')' if $has-default;
        $ret ~= * with $appendix;
        $ret;
    }

    method string(Str $s --> Str) {
        "'" ~ $s.subst(/(<[\\ ']>)/, { "\\$0" }, :g) ~ "'";
    }
    method boolean($b --> Str) { $b.Str.lc }
    method null-value(--> Str) { 'null' }

    method table-string(Str $t --> Str) {
        self.string('{{%' ~ $t ~ '}}');
    }
}

class Yii2Exporter does MigrationExporter {
    has Str:D      $.indent       is required;
    has IO::Path:D $.path         is required;
    has Str:D      $.class-prefix = 'm%y%m%d_%H%M%S_';
    has Int:D      $.dir-chmod    = 0o775;

    has DateTime $!time;

    submethod TWEAK() {
        my %formats = (
            '%' => ['%%'  , Nil],
            Y   => ['%04d', { .year       }],
            y   => ['%02d', { .year % 100 }],
            'm' => ['%02d', { .month      }],
            d   => ['%02d', { .day        }],
            H   => ['%02d', { .hour       }],
            M   => ['%02d', { .minute     }],
            'S' => ['%02d', { .second     }],
        );
        my @params-getters;
        my sub pass(Str:D $char) {
            with %formats{$char} {
                my ($placeholder, $getter) = @($_);
                @params-getters.push($getter)   with $getter;
                return $placeholder;
            }
            abort "unknown placholder `%{$char}`";
        }
        my Str $format = $!class-prefix.subst(/ '%' (.) /, { pass($0.Str) }, :g);

        $!time = DateTime.now(
            timezone  => 0,
            formatter => {
                sprintf $format, |@params-getters.map({ $^c(.self) });
            },
        );
    }

    method export(Yii2Migration:D $migration) {
        my Str:D $prefix = $!time.Str;
        $prefix.=subst(/ :i <-[ a..z \d / ]>+ /, '_', :g);
        $prefix.=subst(/ ^ '/'            /, '');
        $prefix.=subst(/   '/' <( '/'+ )> /, '', :g);
        $prefix.=subst(/   '/' $          /, '');

        my ($up, $down, @header) = do with $migration { .up, .down, |.header };

        my Str:D $ns-class = $prefix ~ $up.name.subst('-', '_', :g);
        my Str:D $class    = $ns-class.IO.basename;
        my Str:D $rel-file = $ns-class ~ ".php";

        my IO::Path $filename = $!path.add($rel-file);
        abort "file already exists - `$filename`" if $filename.e;

        given $filename.parent {
            when .e {
                .d or abort "path `{.self}` exists and is not a directory";
            }
            default {
                .mkdir($!dir-chmod);
            }
        }

        my $body = '';

        $body ~= "// $_".trim ~ "\n"    for @header.map({ .subst(/<?after '?'><?before '>'>/, '[⋯]', :g) });
        $body ~= "\n"                   if  @header.elems;

        $body ~=
            "public function {$up.is-dml ?? 'safeUp' !! 'up' }()\n" ~
            "\{\n" ~
            $up.code.indent(4) ~ "\n" ~
            "}\n\n" ~
            "public function {$down.is-dml ?? 'safeDown' !! 'down'}()\n" ~
            "\{\n" ~
            $down.code.indent(4) ~ "\n" ~
            '}';

        my $code = '<?php' ~ "\n\n" ~ 'use yii\db\Migration;' ~ "\n\n" ~
            "class $class extends Migration\n" ~
            "\{\n" ~
            $body.indent(4) ~ "\n" ~
            "}\n";

        unless ' ' x 4 eq $migration.indent {
            $code.=subst(/^^(' ' ** 4)+/, { $!indent x $0.elems }, :g);
        }

        $filename.spurt($code, :createonly)
            or X::App::IO.new(pyload => "cannot create file - `$filename`");
        put "* $rel-file";

        $!time.=later(:5second);
    }
}

sub transform(IO::Handle :$input, TransformFormat :$format, MigrationExporter :$exporter) {
    put "$PROJECT_NAME ver. $PROJECT_VER"   if IS_I;
    put "Interactive mode"                  if IS_I;
    print '> '                              if IS_I;

    my @migrations;
    my Int $line_number = 0;

    # https://rt.perl.org/Public/Bug/Display.html?id=132076
    # last/next inside CATCH does not work ever - neither anonymouse nor labeled
    #
    # `IO::Handle.lines` reads input lazily. Label for the loop
    # could not be found - an exception cause some corruptions.
    #
    # So, here is `Bool $goto-next` to solve CATCH blocks.
    for $input.lines -> $line {
        NEXT {
            print '> '      if IS_I;
        }
        LAST {
            put '(EOF)'     if IS_I;
        }

        ++$line_number;
        next unless $line.trim;
        my $statement;
        my $goto-next = False;
        try {
            $statement = MigrationSource.parse($line, actions => MigrationSourceActions);

            CATCH {
                when X::App::MatchFail {
                    if IS_I {
                        put "Syntax: $_";
                        # next;
                        $goto-next = True;
                    }
                    else {
                        abort "syntax: $_ - at line $line_number";
                    }
                }
                when X::App::Runtime {
                    if IS_I {
                        put "{.^name}: $_";
                        # next;
                        $goto-next = True;
                    }
                    else {
                        abort "{.^name}: $_ - at line $line_number";
                    }
                }
            }
        }
        next if $goto-next;
        unless $statement {
            if IS_I {
                put 'Syntax mismatch';
                next;
            }
            abort "cannot match at line $line_number\n";
        }

        next if ST_EMPTY eq $statement.made<statement>;

        my $migration;
        try {
            $migration = {
                migration => $format.make-migration($statement),
                line      => $line_number,
            };

            CATCH {
                when X::App::Runtime {
                    if IS_I {
                        put "{.^name}: $_";
                        # next;
                        $goto-next = True;
                    }
                    else {
                        abort "{.^name}: $_ - at line $line_number";
                    }
                }
            }
        }
        next if $goto-next;

        if IS_I {
            try {
                $exporter.export($migration<migration>);
                CATCH {
                    when X::App::Runtime {
                        put "{.^name}: $_";
                        # next;
                        # nothing to skip
                    }
                }
            }
        }
        else {
            @migrations.push($migration);
        }
    }

    for @migrations -> $item {
        try {
            $exporter.export($item<migration>);
            CATCH {
                when X::App::Runtime {
                    abort "{.^name}: $_ - at line $item<line>";
                }
            }
        }
    }
}

my constant DEFAULT_INDENT = ' ' x 4;

my %*SUB-MAIN-OPTS = (
    :named-anywhere,
);

multi sub MAIN('yii2', 'list-types') {
    .put for Yii2Format.data-types.sort;
}

multi sub MAIN('yii2',
    Str:D :$path         = './migrations',
    Str:D :$indent       = DEFAULT_INDENT,
    Str:D :$class-prefix = 'm%y%m%d_%H%M%S_',
    Str:D :$dir-chmod    = '775',
) {
    my $path_io = $path.IO;
    with $path_io {
        unless .e && .d {
            abort "given path either does not exist or is not a directory - {.self}";
        }
    }

    transform(
        input    => $*IN,
        format   => Yii2Format.new,
        exporter => Yii2Exporter.new(
            :path($path_io),
            :$indent,
            :$class-prefix,
            :dir-chmod(:8($dir-chmod))
        ),
    );
}

multi sub MAIN() {
    transform(
        input    => $*IN,
        format   => Yii2Format.new,
        exporter => DebugExporter.new,
    );
}

sub get-usage() {
    Q:c:to/_END/;
    Usage:
        {$*PROGRAM-NAME}

        {$*PROGRAM-NAME} yii2 [<options>]
        {$*PROGRAM-NAME} yii2 list-types

        {$*PROGRAM-NAME} man
    _END
}

multi sub MAIN('man') {
    print Q:c:to/_END/;
    {$PROJECT_NAME} v{$PROJECT_VER}

    {get-usage()}
    Description
        Generates migrations from short stupid weird script.

        Without arguments reads source script from the input and writes result
        in debug style to output. When both input and output are terminal then
        interactive mode will be enabled.

        `yii2` subset toggles Yii2 migrations to be generated into given directory.

    Options

        **yii2**

        --class-prefix=<format>
            Format to generate path and filename prefix for migrations under
            the `--path` directory. Default format `m%y%m%d_%H%M%S_` will
            produce classes names like so:

                m170829_150305_create_user
                m170829_150310_add_idx_user_mail
                ...

            Supported placeholders from `date(1)` are: %Y %y %m %d %H %M %S.

            Format can contain `/` to create subdirectories.

        --dir-chmod=<mode>
            Permissions for subdirectories produced by `--class-prefix`
            with `/` in format. Octal number. Default is `775`.

        --indent=string
            One level indention string. Will be used literally in generated
            result. Default is four spaces.
            To use TAB follow instructions for you shell. For example in Bash
            you can use C-style string: $'\t' .

        --path=<path>
            Base path to store generated migrations. Path must to exist. Default
            is `./migrations` .

    _END
}

sub USAGE() {
    print get-usage();
}
