#!/usr/bin/env perl6

use v6.c;

my constant $PROJECT_NAME = 'Lazy Migration Generator';
my constant $PROJECT_VER  = '0.0.1';

class X::App::MatchFail is X::AdHoc {}
class X::App::Runtime is X::AdHoc {}
class X::App::Unsupported is X::App::Runtime {}
class X::App::IO is X::App::Runtime {}

class X::App::Abort is X::AdHoc {
    multi method gist(X::App::Abort:D:) { $.payload }
}

sub abort(Str:D $message) {
    die X::App::Abort.new(payload => $message);
}

grammar MigrationSource {
    token ws { <!ww> \h* }

    token number {
        [ 0 || <[1..9]> \d* ]
        [ \. ~ \d+ <?> ]?
        [ :i <[-+]>? e ~ \d+ <?> ]?
    }
    token string { \' ~ \' [ <-[' \\]>+ || \\. ]* }
    token value_keyword { :i <<[TRUE|FALSE|NULL]>> }
    token name {
        <!before <[ - \d ]> >
        [ <[ _ a..z \d ]>+ | \\. ]+ % '-'
    }
    token null_mark { '?' }

    rule default_value {
        '=' ~ [
            [<number> | <string>]
            || <value_keyword>
        ] <?> }
    rule params { '(' ~ ')' [ <number>* % ',' ] }
    rule type {
        [':' ~ <name> <?>]
        <params>?
        <null_mark>?
        <default_value>?
    }
    rule column_definition { <name> ~ <type> <?> }

    rule create_table_body { '(' ~ ')' [ <column_definition>* % ',' ] }

    token pos_first { '^' }
    token pos_after { '>' }
    rule position { <pos_first> | [<pos_after> ~ <name> <?>] }
    rule alter_column_type { <type> <position>? }

    token alias { '@' ~ <name> <?> }
    rule table { '%' ~ <name> <?> }

    rule alter_column_name { '=>' ~ <name> <?> }
    rule alter_column_spec {
        <alter_column_name>
        | <from=alter_column_type> ~ [ '=>' ~ <to=alter_column_type> <?> ] <?>
    }
    rule alter_column { '.' ~ [<name> ~ <alter_column_spec> <?>] <?> }
    rule rename_table { '=>' ~ <table> <?> }

    rule table_columns_ref {
        <table>
        ~
        ['.' ~ <columns=name> ** 1 <?> | '(' ~ ')' [ <columns=name>+ % ',' ]]
        <?>
    }

    token fk_restrict { '!' }
    token fk_cascade { '>' }
    token fk_set_null { '?' }
    token fk_verb { <fk_restrict> | <fk_cascade> | <fk_set_null> }
    token fk_on_delete { '~' ~ <fk_verb> <?> }
    token fk_on_update { '*' ~ <fk_verb> <?> }
    rule fk_statement {
        <<FK>> ~ [
            <alias>? ~ [
                <source=table_columns_ref> ~ [
                    '=>' ~ <target=table_columns_ref> <?>
                ] <?>
            ] <?>
        ] <?>
        [
            <fk_on_delete> <fk_on_update>?
            | <fk_on_update> <fk_on_delete>?
        ]?
    }

    token index_type { << [I | U | PK] >> }
    rule key_statement {
        <index_type> ~ [
            <alias>? ~ <table_columns_ref> <?>
        ] <?>
    }

    rule add_column_body { '.' ~ [<name> ~ <alter_column_type> <?>] <?> }
    rule table_ddl_statement {
        <table> ~ [<create_table_body> | <add_column_body>] <?>
    }

    rule ddl_statement {
        <table_ddl_statement>
        | <key_statement>
        | <fk_statement>
    }

    rule create_statement { '+' ~ <ddl_statement> <?> }
    rule drop_statement { '-' ~ <ddl_statement> <?> }
    rule data_statement { '=' }
    rule alter_statement {
        '*' ~ [
            <table> ~ [<rename_table> | <alter_column>] <?>
        ] <?>
    }

    rule statement {
        ^^ ~ $$
        [
            <create_statement>
            | <drop_statement>
            | <alter_statement>
            | <data_statement>
        ]
    }
    rule TOP { <statement>* % [$ | \n] }

    method FAILGOAL($goal) {
        my $after = self.target.substr((self.pos - 10 max 0) ..^ self.pos);
        $after = $after
            ?? ' after `' ~ (self.pos > 10 ?? '...' !! '') ~ $after ~ '`'
            !! "";
        my $near = self.pos < self.target.chars
            ?? 'near `'
                ~ self.target.substr(self.pos, 10)
                ~ (self.pos < self.target.chars - 10 ?? '...' !! '')
                ~ '`'
            !! 'instead of EOF';
        die X::App::MatchFail.new(
            payload => "expected `{$goal.trim}`{$after} {$near} at position {self.pos}"
        );
    }
}

class Statement {
    has Str:D $.name = '';
    has Str:D $.code = '';

    multi method gist(Statement: --> Str) {
        "`$!name` ⟨\n" ~
        $!code.indent(4) ~ "\n" ~
        "⟩";
    }
}

class Migration {
    has Match:D     $.source is required;
    has Str:D       @.header;
    has Statement:D $.up     is required;
    has Statement:D $.down   is required;

    method BUILDALL(|) {
        @!header.unshift(
            "Generated with $PROJECT_NAME/$PROJECT_VER",
        );

        callsame;

        @!header.push(
            "",
            "Source:",
            "    $!source",
        );

        self;
    }

    multi method gist(Migration: --> Str) {
        [~] '$> ', self.up.name, "\n",
            |@!header.map({
                "> $_".trim.indent(4) ~ "\n"
            }),
            |(UP => self.up, DOWN => self.down).map({
                (
                    .key ~ ":\n" ~
                    .value.gist.indent(4)
                ).indent(4) ~ "\n"
            }),
            '.';
    }
}

role TransformFormat {
    # Export matched statement to complete migration code
    method make-migration(Match:D $s --> Migration) {
        Migration.new(
            source => $s,
            up     => self.statement($s),
            down   => self.statement($s, :back),
        );
    }

    method create-table(Match:D $s --> Statement) {...}
    method drop-table  (Match:D $s --> Statement) {...}

    method add-column (Match:D $s --> Statement) {...}
    method drop-column(Match:D $s --> Statement) {...}

    method add-primary-key (Match:D $s --> Statement) {...}
    method drop-primary-key(Match:D $s --> Statement) {...}

    method add-unique-key (Match:D $s --> Statement) {...}
    method drop-unique-key(Match:D $s --> Statement) {...}

    method add-index (Match:D $s --> Statement) {...}
    method drop-index(Match:D $s --> Statement) {...}

    method add-foreigh-key (Match:D $s, Bool:D :$back = False --> Statement) {...}
    method drop-foreign-key(Match:D $s, Bool:D :$back = False --> Statement) {...}

    method rename-table(Match:D $s, Bool:D :$back = False --> Statement) {...}

    method alter-column-name(Match:D $s, Bool:D :$back = False --> Statement) {...}
    method alter-column-type(Match:D $s, Bool:D :$back = False --> Statement) {...}

    method data-statement(Match:D $s, Bool:D :$back = False --> Statement) {...}

    method statement(Match:D $s, Bool:D :$back = False --> Statement) {
        my $caps = $s.caps;
        unless 1 === $caps.elems {
            die "expected Match under `<statement>` but got `{$s.caps[0]}`";
        }
        given $caps[0] {
            when .key eq 'create_statement' {
                self.ddl-statement(.value<ddl_statement>, :$back);
            }
            when .key eq 'drop_statement' {
                self.ddl-statement(.value<ddl_statement>, back => !$back);
            }
            when .key eq 'alter_statement' {
                my $st = .value;
                if $st<rename_table>:exists {
                    return self.rename-table($st, :$back);
                }
                my $alt = $st<alter_column><alter_column_spec>;
                if $alt<alter_column_name>:exists {
                    return self.alter-column-name($st, :$back);
                }
                return self.alter-column-type($st, :$back);
            }
            when .key eq 'data_statement' {
                return self.data-statement(.value, :$back);
            }
            default {
                die "expected Match under `<statement>` but got `{.key}`";
            }
        }
    }

    method ddl-statement(Match:D $s, Bool:D :$back = False --> Statement) {
        given $s.caps[0] {
            when .key eq 'table_ddl_statement' {
                if .value<create_table_body>:exists {
                    return self.create-table(.value) unless $back;
                    return self.drop-table(.value);
                }
                return self.add-column(.value) unless $back;
                return self.drop-column(.value);
            }
            when .key eq 'key_statement' {
                my $st = .value;
                given $st<index_type>.Str.uc {
                    when 'PK' {
                        return self.add-primary-key($st) unless $back;
                        return self.drop-primary-key($st);
                    }
                    when 'U' {
                        return self.add-unique-key($st) unless $back;
                        return self.drop-unique-key($st);
                    }
                    when 'I' {
                        return self.add-index($st) unless $back;
                        return self.drop-index($st);
                    }
                    default {
                        die "unexpected index type `$_`";
                    }
                }
            }
            when .key eq 'fk_statement' {
                return self.add-foreigh-key(.value) unless $back;
                return self.drop-foreign-key(.value);
            }
            default {
                die "expected Match under `<ddl_statement>` but got `{.key}`";
            }
        }
    }

    method table(Match:D $t --> Str) {
        return $t<name>.Str;
    }

    method default-value(Match:D $v --> Str) {
        return $v<number>.Str           if $v<number>:exists;
        return $v<value_keyword>.Str.lc if $v<value_keyword>:exists;
        return self.string(
            $v<string>.Str
                .substr(1, *-1)
                .subst(/\\(.)/, { $0 }, :g)
        );
    }

    method string(Str:D $s --> Str) { $s }

    method throw-unsupported(Str:D $message) {
        die X::App::Unsupported.new(payload => $message);
    }
}

role MigrationExporter {
    method export(Migration:D $migration --> Bool) { ... }
}

class DebugExporter does MigrationExporter {
    has IO::Handle $!to = $*OUT;

    method export(Migration:D $migration --> Bool) {
        $!to.say($migration);
    }
}

class Yii2Migration is Migration {
    has Str:D $.indent = '';

    method BUILDALL(|) {
        self.header.unshift("Format: Yii2");

        callsame;
        self;
    }
}

class Yii2Format does TransformFormat {
    has Str:D $.indent = '';

    my constant UNSIGNED         = '->unsigned()';
    my constant MAX_INDEX_LENGTH = 64;

    my constant %types = {
        primary      => {:t<primaryKey>,    :D},
        uprimary     => {:T<primaryKey>,    :D, :a(UNSIGNED)},
        primary-big  => {:t<bigPrimaryKey>, :D},
        uprimary-big => {:t<bigPrimaryKey>, :D, :a(UNSIGNED)},
        char         => True,
        string       => True,
        text         => True,
        int16        => 'smallInteger',
        uint16       => ['smallInteger', UNSIGNED],
        int          => 'integer',
        uint         => ['integer', UNSIGNED],
        bigint       => 'bigInteger',
        uint64       => ['bigInteger', UNSIGNED],
        float        => True,
        double       => True,
        decimal      => True,
        date         => True,
        datetime     => 'dateTime',
        time         => True,
        timestamp    => True,
        binary       => True,
        bool         => 'boolean',
        money        => True,
    };

    my constant FK_ACTION = {
        fk_restrict => 'RESTRICT',
        fk_cascade  => 'CASCADE',
        fk_set_null => 'SET NULL',
    };

    my constant S_FK = 'fk';
    my constant S_PK = 'pk';
    my constant S_IDX = 'idx';

    method make-migration(Match:D $s --> Migration) {
        Yii2Migration.new(
            source => $s,
            up     => self.statement($s),
            down   => self.statement($s, :back),
            indent => $!indent,
        );
    }

    method create-table(Match:D $s --> Statement) {
        my ($table, $create) = $s<table create_table_body>;
        Statement.new(
            :name("create_{$table<name>}"),
            :code(
                [~] '$tableOptions = null;', "\n",
                    q[if ($this->db->driverName === 'mysql') {], "\n",
                    $!indent, '// https://stackoverflow.com/q/766809', "\n",
                    $!indent, q[$tableOptions = 'CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE=InnoDB';], "\n",
                    "}\n",
                    "\n",
                    '$this->createTable(', self.table-string($table), ", [\n",
                    $!indent,
                    $create<column_definition>.list.map({
                        my ($name, $type) = .hash<name type>;
                        [~] self.string($name.Str), ' => ', self.column-type($type), ',';
                    }).join("\n" ~ $!indent),
                    "\n",
                    '], $tableOptions);',
            ),
        );
    }
    method drop-table(Match:D $s --> Statement) {
        my ($table) = $s<table>;
        Statement.new(
            :name("drop_{$table<name>}"),
            :code([~] '$this->dropTable(', self.table-string($table), ');')
        );
    }

    method add-column(Match:D $s --> Statement) {
        my ($table, $add_col) = $s<table add_column_body>;
        my ($column, $type_pos) = $add_col<name alter_column_type>;
        Statement.new(
            :name("add_{$table<name>}_$column"),
            :code(
                [~] '$this->addColumn(', "\n",
                    $!indent, self.table-string($table), ",\n",
                    $!indent, self.string($column.Str), ",\n",
                    $!indent, self.column-type-pos($type_pos), "\n",
                    ');',
            )
        );
    }
    method drop-column(Match:D $s --> Statement) {
        my ($table, $add_col) = $s<table add_column_body>;
        my ($column) = $add_col<name>;
        Statement.new(
            :name("drop_{$table<name>}_$column"),
            :code(
                [~] '$this->dropColumn(',
                    self.table-string($table), ', ',
                    self.string($column.Str), ');'
            )
        );
    }

    method add-primary-key(Match:D $s --> Statement) {
        self!index-common($s, 'add_', 'addPrimaryKey', S_PK, :cols);
    }
    method drop-primary-key(Match:D $s --> Statement) {
        self!index-common($s, 'drop_', 'dropPrimaryKey', S_PK);
    }

    method add-unique-key(Match:D $s --> Statement) {
        self!index-common($s, 'add_', 'createIndex', S_IDX, :cols, :tag<true>);
    }
    method drop-unique-key(Match:D $s --> Statement) {
        self!index-common($s, 'drop_', 'dropIndex', S_IDX);
    }

    method add-index(Match:D $s --> Statement) {
        self!index-common($s, 'add_', 'createIndex', S_IDX, :cols, :tag<false>);
    }
    method drop-index(Match:D $s --> Statement) {
        self!index-common($s, 'drop_', 'dropIndex', S_IDX);
    }

    method !index-common(Match:D $s, Str $namePrefix, Str $method, Str $prefix, Bool:D :$cols = False, Str :$tag --> Statement) {
        my ($alias, $ref) = $s<alias table_columns_ref>;
        my $index_name = self.index-name($prefix, $alias, $ref);
        Statement.new(
            :name($namePrefix ~ $index_name),
            :code(
                [~] '$this->', $method, "(\n",
                    $!indent, self.string($index_name), ",\n",
                    $!indent, self.table-string($ref<table>),
                    $cols
                        ?? (
                            ",\n",
                            $!indent, '[',
                            $ref<columns>.list.map({ self.string(.Str) }).join(', '),
                            ']'
                        ).join('')
                        !! '',
                    $tag
                        ?? (",\n", $!indent, $tag).join('')
                        !! '',
                    "\n",
                    ');',
            )
        );
    }

    method add-foreigh-key(Match:D $s, Bool:D :$back = False --> Statement) {
        my ($a, $f, $t, $d, $u) = $s<alias source target fk_on_delete fk_on_update>;
        ($f, $t) = $t, $f if $back;
        my $index_name = self.index-name(S_FK, $a, $f, $t);
        Statement.new(
            :name("add_$index_name"),
            :code(
                [~] '$this->addForeignKey(', "\n",
                    $!indent, self.string($index_name), ",\n",
                    $!indent, self.table-string($f<table>), ', [',
                    $f<columns>.list.map({ self.string(.Str) }).join(', '), "],\n",
                    $!indent, self.table-string($t<table>), ', [',
                    $t<columns>.list.map({ self.string(.Str) }).join(', '), "],\n",
                    $!indent, self.fk-action-string($d), ",\n",
                    $!indent, self.fk-action-string($u), "\n",
                    ');',
            )
        );
    }
    method drop-foreign-key(Match:D $s, Bool:D :$back = False --> Statement) {
        my ($a, $f, $t) = $s<alias source target>;
        ($f, $t) = $t, $f if $back;
        my $index_name = self.index-name(S_FK, $a, $f, $t);
        Statement.new(
            :name("drop_$index_name"),
            :code(
                [~] '$this->dropForeignKey(', "\n",
                    $!indent, self.string($index_name), ",\n",
                    $!indent, self.table-string($f<table>), "\n",
                    ');',
            )
        );
    }
    method index-name(Str $prefix, $alias, *@table-col-refs --> Str) {
        return $alias<name>.Str if $alias ~~ Match:D;
        my @tables;
        my @columns;
        # $*ERR.say(@table-col-refs);
        for @table-col-refs {
            # $*ERR.say($(:TABLE($_<table>), :COLUMNS($_<columns>)));
            push |.list for @tables, @columns Z $_<table>, $_<columns>;
        }
        # $*ERR.say($(:@tables, :@columns));
        for @tables {
            $_ = self.table($_);
        }
        @columns».=Str;
        # $*ERR.say($(:@tables, :@columns).perl);

        my @refs = (@tables Z @columns).flat;

        while @refs {
            with ($prefix, @refs.map({ .list })).flat.join('-') {
                .return if .chars <= MAX_INDEX_LENGTH;
            }
            @refs.pop;
        }
        die "too long index name in any case";
    }

    method rename-table(Match:D $s, Bool:D :$back = False --> Statement) {
        my ($from_table, $to_table) = $s<table rename_table>;
        $to_table = $to_table<table>;
        ($from_table, $to_table) = $to_table, $from_table if $back;
        Statement.new(
            :name("rename_{$from_table<name>}_{$to_table<name>}"),
            :code(
                [~] '$this->renameTable(',
                    self.table-string($from_table), ', ',
                    self.table-string($to_table), ');',
            )
        );
    }

    method alter-column-name(Match:D $s, Bool:D :$back = False --> Statement) {
        my $table = $s<table>;
        my ($from_name, $to_name) = $s<alter_column><name alter_column_spec>;
        $from_name .= Str;
        $to_name = $to_name<alter_column_name><name>.Str;
        ($from_name, $to_name) = $to_name, $from_name if $back;
        Statement.new(
            :name("rename_{$table<name>}_{$from_name}_{$to_name}"),
            :code(
                [~] '$this->renameColumn(',
                    self.table-string($table), ', ',
                    self.string($from_name), ', ',
                    self.string($to_name), ');',
            )
        );
    }
    method alter-column-type(Match:D $s, Bool:D :$back = False --> Statement) {
        my $table = $s<table>;
        my ($name, $spec) = $s<alter_column><name alter_column_spec>;
        $name .= Str;
        my $type = $spec{$back ?? 'from' !! 'to'};
        Statement.new(
            :name("alter_{$table<name>}_$name"),
            :code(
                [~] '$this->alterColumn(', "\n",
                    $!indent, self.table-string($table), ",\n",
                    $!indent, self.string($name), ",\n",
                    $!indent, self.column-type-pos($type), "\n",
                    ');',
            )
        );
    }

    method data-statement(Match:D $s, Bool:D :$back = False --> Statement) {
        Statement.new(
            :name('update')
            :code(
                [~] '// TODO: ',
                    $back
                        ?? 'undo that updates'
                        !! 'add some updates',
            ),
        );
    }

    method column-type-pos(Match:D $t --> Str) {
        my ($type, $pos) = $t<type position>;
        $type = self.column-type($type);
        return $type without $pos;
        return $type ~ '->first()' if $pos<pos_first>;
        return $type ~ '->after(' ~ self.string($pos<name>.Str) ~ ')';
    }

    method column-type(Match:D $t --> Str) {
        my ($name, $params, $null, $default) = $t<name params null_mark default_value>;
        $name .= Str;
        $params = $params
            ?? $params<number>».Str.join(', ')
            !! '';

        %types{$name}:exists or die "unknown type `$name`";
        my ($type, $appendix, $defined) = do given %types{$name} {
            when * === True { ($name,) }
            when Str:D { (.self,) }
            when List { .self }
            when Map { @(.self<t a D>) }
            default {
                die "bad type declaration for `$name`";
            }
        };

        my $ret = [~] '$this->', $type, '(', $params, ')';
        if $defined {
            with $null {
                self.throw-unsupported(
                    "type `$name` (`$type`) is strictly defined so it cannot be NULL"
                );
            }
        }
        else {
            $ret ~= '->notNull()' without $null;
        }
        $ret ~= '->defaultValue(' ~ self.default-value($default) ~ ')' with $default;
        $ret ~= * with $appendix;
        $ret;
    }

    method string(Str $s --> Str) {
        "'" ~ $s.subst(/(<[\\ ']>)/, { "\\$0" }, :g) ~ "'";
    }

    method table-string(Match:D $t --> Str) {
        self.string('{{%' ~ self.table($t) ~ '}}');
    }

    multi method fk-action-string(Match:D $on) {
        my $action = $on<fk_verb>.hash.keys[0];
        die "unexpected FK action `$action`" unless FK_ACTION{$action}:exists;
        self.string(FK_ACTION{$action});
    }
    multi method fk-action-string(Any:U) {
        self.string(FK_ACTION<fk_restrict>);
    }
}

class Yii2Exporter does MigrationExporter {
    has IO::Path:D $.path is required;

    has DateTime $!time;

    submethod TWEAK() {
        $!time = DateTime.now(
            timezone  => 0,
            formatter => {
                sprintf "%04d%02d%02d_%02d%02d%02d", .year, .month, .day, .hour, .minute, .second;
            },
        );
    }

    method export(Yii2Migration:D $migration) {
        my $class_name = 'm' ~ $!time.Str ~ '_' ~ $migration.up.name.subst('-', '_', :g);
        my IO::Path $filename = $!path.add($class_name ~ ".php");
        die "file already exists - `$filename`" if $filename.e;

        my $body = '';
        $body ~= "// $_".trim ~ "\n" for $migration.header;
        $body ~= "\n" if $migration.header.elems;
        $body ~=
            "public function up()\n" ~
            "\{\n" ~
            $migration.up.code.indent(4) ~ "\n" ~
            "}\n\n" ~
            "public function down()\n" ~
            "\{\n" ~
            $migration.down.code.indent(4) ~ "\n" ~
            '}';

        my $code = '<?php' ~ "\n\n" ~ 'use yii\db\Migration;' ~ "\n\n" ~
            "class $class_name extends Migration\n" ~
            "\{\n" ~
            $body.indent(4) ~ "\n" ~
            "}\n";

        unless ' ' x 4 eq $migration.indent {
            $code.=subst(/^^(' ' ** 4)+/, { $migration.indent x $0.elems }, :g);
        }

        $filename.spurt($code, :createonly)
            or X::App::IO.new(pyload => "cannot create file - `$filename`");

        $!time.=later(:5second);
    }
}

sub transform(IO::Handle :$input, TransformFormat :$format, MigrationExporter :$exporter) {
    my @migrations;
    my Int $line_number = 0;
    for $input.lines -> $line {
        ++$line_number;
        next unless $line.trim;
        my $statement;
        try {
            $statement = MigrationSource.parse($line, rule => 'statement');
            CATCH {
                when X::App::MatchFail {
                    abort "syntax: $_ - at line $line_number";
                }
            }
        }
        $statement or abort "cannot match at line $line_number\n";
        try {
            @migrations.push({
                migration => $format.make-migration($statement),
                line => $line_number,
            });
            CATCH {
                when X::App::Runtime {
                    abort "{.^name}: $_ - at line $line_number";
                }
            }
        }
    }

    for @migrations -> $item {
        try {
            $exporter.export($item<migration>);
            CATCH {
                when X::App::Runtime {
                    abort "{.^name}: $_ - at line $item<line>";
                }
            }
        }
    }
}

my constant DEFAULT_INDENT = ' ' x 4;

multi sub MAIN('yii2',
    Str:D :$path   = './migrations',
    Str:D :$indent = DEFAULT_INDENT,
) {
    my $path_io = $path.IO;
    with $path_io {
        unless .e && .d {
            abort "given path either does not exist or is not a directory - {.self}";
        }
    }

    transform(
        input    => $*IN,
        format   => Yii2Format.new(:$indent),
        exporter => Yii2Exporter.new(path => $path_io),
    );
}

multi sub MAIN(
    Str:D :$indent = DEFAULT_INDENT,
) {
    transform(
        input    => $*IN,
        format   => Yii2Format.new(:$indent),
        exporter => DebugExporter.new,
    );
}
