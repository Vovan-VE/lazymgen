#!/usr/bin/env perl6

use v6.c;

my constant $PROJECT_NAME = 'Lazy Migration Generator';
my constant $PROJECT_VER  = '0.0.1';

class X::App::MatchFail is X::AdHoc {}
class X::App::Unsupported is X::AdHoc {}

class X::App::Abort is X::AdHoc {
    multi method gist(X::App::Abort:D:) { $.payload }
}

sub abort(Str:D $message) {
    die X::App::Abort.new(payload => $message);
}

grammar MigrationSource {
    token ws { <!ww> \h* }

    token number {
        [ 0 || <[1..9]> \d* ]
        [ \. ~ \d+ <?> ]?
        [ :i <[-+]>? e ~ \d+ <?> ]?
    }
    token string { \' ~ \' [ <-[' \\]>+ || \\. ]* }
    token value_keyword { :i <<[TRUE|FALSE|NULL]>> }
    token name {
        <!before <[ - \d ]> >
        [ <[ _ a..z \d ]>+ | \\. ]+ % '-'
    }
    token null_mark { '?' }

    rule default_value {
        '=' ~ [
            [<number> | <string>]
            || <value_keyword>
        ] <?> }
    rule params { '(' ~ ')' [ <number>* % ',' ] }
    rule type {
        [':' ~ <name> <?>]
        <params>?
        <null_mark>?
        <default_value>?
    }
    rule column_definition { <name> ~ <type> <?> }

    rule create_table_body { '(' ~ ')' [ <column_definition>* % ',' ] }

    token pos_first { '^' }
    token pos_after { '>' }
    rule position { <pos_first> | [<pos_after> ~ <name> <?>] }
    rule alter_column_type { <type> <position>? }

    token alias { '@' ~ <name> <?> }
    rule table { '%' ~ <name> <?> }

    rule alter_column_name { '=>' ~ <name> <?> }
    rule alter_column_spec {
        <alter_column_name>
        | <from=alter_column_type> ~ [ '=>' ~ <to=alter_column_type> <?> ] <?>
    }
    rule alter_column { '.' ~ [<name> ~ <alter_column_spec> <?>] <?> }
    rule rename_table { '=>' ~ <table> <?> }

    rule table_columns_ref {
        <table>
        ~
        ['.' ~ <columns=name> ** 1 <?> | '(' ~ ')' [ <columns=name>+ % ',' ]]
        <?>
    }

    token fk_restrict { '!' }
    token fk_cascade { '>' }
    token fk_set_null { '?' }
    token fk_verb { <fk_restrict> | <fk_cascade> | <fk_set_null> }
    token fk_on_delete { '~' ~ <fk_verb> <?> }
    token fk_on_update { '*' ~ <fk_verb> <?> }
    rule fk_statement {
        <<FK>> ~ [
            <alias>? ~ [
                <source=table_columns_ref> ~ [
                    '=>' ~ <target=table_columns_ref> <?>
                ] <?>
            ] <?>
        ] <?>
        [
            <fk_on_delete> <fk_on_update>?
            | <fk_on_update> <fk_on_delete>?
        ]?
    }

    token index_type { << [I | U | PK] >> }
    rule key_statement {
        <index_type> ~ [
            <alias>? ~ <table_columns_ref> <?>
        ] <?>
    }

    rule add_column_body { '.' ~ [<name> ~ <alter_column_type> <?>] <?> }
    rule table_ddl_statement {
        <table> ~ [<create_table_body> | <add_column_body>] <?>
    }

    rule ddl_statement {
        <table_ddl_statement>
        | <key_statement>
        | <fk_statement>
    }

    rule create_statement { '+' ~ <ddl_statement> <?> }
    rule drop_statement { '-' ~ <ddl_statement> <?> }
    rule data_statement { '=' }
    rule alter_statement {
        '*' ~ [
            <table> ~ [<rename_table> | <alter_column>] <?>
        ] <?>
    }

    rule statement {
        ^^ ~ $$
        [
            <create_statement>
            | <drop_statement>
            | <alter_statement>
            | <data_statement>
        ]
    }
    rule TOP { <statement>* % [$ | \n] }

    method FAILGOAL($goal) {
        my $after = self.target.substr((self.pos - 10 max 0) ..^ self.pos);
        $after = $after
            ?? ' after `' ~ (self.pos > 10 ?? '...' !! '') ~ $after ~ '`'
            !! "";
        my $near = self.pos < self.target.chars
            ?? 'near `'
                ~ self.target.substr(self.pos, 10)
                ~ (self.pos < self.target.chars - 10 ?? '...' !! '')
                ~ '`'
            !! 'instead of EOF';
        die X::App::MatchFail.new(
            payload => "expected `{$goal.trim}`{$after} {$near} at position {self.pos}"
        );
    }
}

class Migration {
    has Match:D $.source is required;
    has Str:D $.up = '';
    has Str:D $.down = '';
}

role TransformFormat {
    # Export matched statement to complete migration code
    method export-migration(Match:D $s --> Migration) {
        Migration.new(
            source => $s,
            up     => self.statement($s),
            down   => self.statement($s, :back),
        );
    }

    method create-table(Match:D $s --> Str) {...}
    method drop-table  (Match:D $s --> Str) {...}

    method add-column (Match:D $s --> Str) {...}
    method drop-column(Match:D $s --> Str) {...}

    method add-primary-key (Match:D $s --> Str) {...}
    method drop-primary-key(Match:D $s --> Str) {...}

    method add-unique-key (Match:D $s --> Str) {...}
    method drop-unique-key(Match:D $s --> Str) {...}

    method add-index (Match:D $s --> Str) {...}
    method drop-index(Match:D $s --> Str) {...}

    method add-foreigh-key (Match:D $s, Bool:D :$back = False --> Str) {...}
    method drop-foreign-key(Match:D $s, Bool:D :$back = False --> Str) {...}

    method rename-table(Match:D $s, Bool:D :$back = False --> Str) {...}

    method alter-column-name(Match:D $s, Bool:D :$back = False --> Str) {...}
    method alter-column-type(Match:D $s, Bool:D :$back = False --> Str) {...}

    method data-statement(Match:D $s, Bool:D :$back = False --> Str) {...}

    method statement(Match:D $s, Bool:D :$back = False --> Str) {
        my $caps = $s.caps;
        unless 1 === $caps.elems {
            die "expected Match under `<statement>` but got `{$s.caps[0]}`";
        }
        given $caps[0] {
            when .key eq 'create_statement' {
                self.ddl-statement(.value<ddl_statement>, :$back);
            }
            when .key eq 'drop_statement' {
                self.ddl-statement(.value<ddl_statement>, back => !$back);
            }
            when .key eq 'alter_statement' {
                my $st = .value;
                if $st<rename_table>:exists {
                    return self.rename-table($st, :$back);
                }
                my $alt = $st<alter_column><alter_column_spec>;
                if $alt<alter_column_name>:exists {
                    return self.alter-column-name($st, :$back);
                }
                return self.alter-column-type($st, :$back);
            }
            when .key eq 'data_statement' {
                return self.data-statement(.value, :$back);
            }
            default {
                die "expected Match under `<statement>` but got `{.key}`";
            }
        }
    }

    submethod ddl-statement(Match:D $s, Bool:D :$back = False --> Str) {
        given $s.caps[0] {
            when .key eq 'table_ddl_statement' {
                if .value<create_table_body>:exists {
                    return self.create-table(.value) unless $back;
                    return self.drop-table(.value);
                }
                return self.add-column(.value) unless $back;
                return self.drop-column(.value);
            }
            when .key eq 'key_statement' {
                my $st = .value;
                given $st<index_type>.Str.uc {
                    when 'PK' {
                        return self.add-primary-key($st) unless $back;
                        return self.drop-primary-key($st);
                    }
                    when 'U' {
                        return self.add-unique-key($st) unless $back;
                        return self.drop-unique-key($st);
                    }
                    when 'I' {
                        return self.add-index($st) unless $back;
                        return self.drop-index($st);
                    }
                    default {
                        die "unexpected index type `$_`";
                    }
                }
            }
            when .key eq 'fk_statement' {
                return self.add-foreigh-key(.value) unless $back;
                return self.drop-foreign-key(.value);
            }
            default {
                die "expected Match under `<ddl_statement>` but got `{.key}`";
            }
        }
    }

    method table(Match:D $t --> Str) {
        return $t<name>.Str;
    }

    method default-value(Match:D $v --> Str) {
        return $v<number>.Str           if $v<number>:exists;
        return $v<value_keyword>.Str.lc if $v<value_keyword>:exists;
        return self.string(
            $v<string>.Str
                .substr(1, *-1)
                .subst(/\\(.)/, { $0 }, :g)
        );
    }

    method string(Str:D $s --> Str) { $s }

    method throw-unsupported(Str:D $message) {
        die X::App::Unsupported.new(payload => $message);
    }
}

class Yii2Migration is Migration {
    has Str:D $.indent = '';

    multi method gist(Yii2Migration: --> Str) {
        [~] '=' x 20, "\{\n",
            $!indent, 'HEAD', '-' x 10, "\n",
            $!indent, "// generated with $PROJECT_NAME/$PROJECT_VER from statement:\n",
            $!indent, "//\n",
            $!indent, '// ', self.source.Str, "\n",
            $!indent, 'UP', '-' x 12, "\n",
            $!indent x 2, self.up, "\n",
            $!indent, 'DOWN', '-' x 10, "\n",
            $!indent x 2, self.down, "\n",
            "}";
    }
}

class Yii2Format does TransformFormat {
    has Str:D $.indent = '';

    my constant UNSIGNED         = '->unsigned()';
    my constant MAX_INDEX_LENGTH = 64;

    my constant %types = {
        primary      => {:t<primaryKey>,    :D},
        uprimary     => {:T<primaryKey>,    :D, :a(UNSIGNED)},
        primary-big  => {:t<bigPrimaryKey>, :D},
        uprimary-big => {:t<bigPrimaryKey>, :D, :a(UNSIGNED)},
        char         => True,
        string       => True,
        text         => True,
        int16        => 'smallInteger',
        uint16       => ['smallInteger', UNSIGNED],
        int          => 'integer',
        uint         => ['integer', UNSIGNED],
        bigint       => 'bigInteger',
        uint64       => ['bigInteger', UNSIGNED],
        float        => True,
        double       => True,
        decimal      => True,
        date         => True,
        datetime     => 'dateTime',
        time         => True,
        timestamp    => True,
        binary       => True,
        bool         => 'boolean',
        money        => True,
    };

    my constant FK_ACTION = {
        fk_restrict => 'RESTRICT',
        fk_cascade  => 'CASCADE',
        fk_set_null => 'SET NULL',
    };

    my constant S_FK = 'fk';
    my constant S_PK = 'pk';
    my constant S_IDX = 'idx';

    method export-migration(Match:D $s --> Migration) {
        Yii2Migration.new(
            source => $s,
            up     => self.statement($s),
            down   => self.statement($s, :back),
            indent => $!indent,
        );
    }

    method create-table(Match:D $s --> Str) {
        my ($table, $create) = $s<table create_table_body>;
        [~] '$tableOptions = null;', "\n",
            $!indent x 2, q[if ($this->db->driverName === 'mysql') {], "\n",
            $!indent x 3, '// https://stackoverflow.com/q/766809', "\n",
            $!indent x 3, q[$tableOptions = 'CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE=InnoDB';], "\n",
            $!indent x 2, "}\n",
            "\n",
            $!indent x 2, '$this->createTable(', self.table-string($table), ", [\n",
            $!indent x 3,
            $create<column_definition>.list.map({
                my ($name, $type) = .hash<name type>;
                [~] self.string($name.Str), ' => ', self.column-type($type), ',';
            }).join("\n" ~ $!indent x 3),
            "\n",
            $!indent x 2, '], $tableOptions);';
    }
    method drop-table(Match:D $s --> Str) {
        my ($table) = $s<table>;
        [~] '$this->dropTable(', self.table-string($table), ');';
    }

    method add-column(Match:D $s --> Str) {
        my ($table, $add_col) = $s<table add_column_body>;
        my ($column, $type_pos) = $add_col<name alter_column_type>;
        [~] '$this->addColumn(', "\n",
            $!indent x 3, self.table-string($table), ",\n",
            $!indent x 3, self.string($column.Str), ",\n",
            $!indent x 3, self.column-type-pos($type_pos), "\n",
            $!indent x 2, ');';
    }
    method drop-column(Match:D $s --> Str) {
        my ($table, $add_col) = $s<table add_column_body>;
        my ($column) = $add_col<name>;
        [~] '$this->dropColumn(',
            self.table-string($table), ', ',
            self.string($column.Str), ');';
    }

    method add-primary-key(Match:D $s --> Str) {
        self!index-common($s, 'addPrimaryKey', S_PK, :cols);
    }
    method drop-primary-key(Match:D $s --> Str) {
        self!index-common($s, 'dropPrimaryKey', S_PK);
    }

    method add-unique-key(Match:D $s --> Str) {
        self!index-common($s, 'createIndex', S_IDX, :cols, :tag<true>);
    }
    method drop-unique-key(Match:D $s --> Str) {
        self!index-common($s, 'dropIndex', S_IDX);
    }

    method add-index(Match:D $s --> Str) {
        self!index-common($s, 'createIndex', S_IDX, :cols, :tag<false>);
    }
    method drop-index(Match:D $s --> Str) {
        self!index-common($s, 'dropIndex', S_IDX);
    }

    method !index-common(Match:D $s, Str $method, Str $prefix, Bool:D :$cols = False, Str :$tag --> Str) {
        my ($alias, $ref) = $s<alias table_columns_ref>;
        [~] '$this->', $method, "(\n",
            $!indent x 3, self.string(self.index-name($prefix, $alias, $ref)), ",\n",
            $!indent x 3, self.table-string($ref<table>),
            $cols
                ?? (
                    ",\n",
                    $!indent x 3, '[',
                    $ref<columns>.list.map({ self.string(.Str) }).join(', '),
                    ']'
                ).join('')
                !! '',
            $tag
                ?? (",\n", $!indent x 3, $tag).join('')
                !! '',
            "\n",
            $!indent x 2, ');';
    }

    method add-foreigh-key (Match:D $s, Bool:D :$back = False --> Str) {
        my ($a, $f, $t, $d, $u) = $s<alias source target fk_on_delete fk_on_update>;
        ($f, $t) = $t, $f if $back;
        [~] '$this->addForeignKey(', "\n",
            $!indent x 3, self.string(self.index-name(S_FK, $a, $f, $t)), ",\n",
            $!indent x 3, self.table-string($f<table>), ', [',
            $f<columns>.list.map({ self.string(.Str) }).join(', '), "],\n",
            $!indent x 3, self.table-string($t<table>), ', [',
            $t<columns>.list.map({ self.string(.Str) }).join(', '), "],\n",
            $!indent x 3, self.fk-action-string($d), ",\n",
            $!indent x 3, self.fk-action-string($u), "\n",
            $!indent x 2, ');';
    }
    method drop-foreign-key(Match:D $s, Bool:D :$back = False --> Str) {
        my ($a, $f, $t) = $s<alias source target>;
        ($f, $t) = $t, $f if $back;
        [~] '$this->dropForeignKey(', "\n",
            $!indent x 3, self.string(self.index-name(S_FK, $a, $f, $t)), ",\n",
            $!indent x 3, self.table-string($f<table>), "\n",
            $!indent x 2, ');';
    }
    submethod index-name(Str $prefix, $alias, *@table-col-refs --> Str) {
        return $alias<name>.Str if $alias ~~ Match:D;
        my @tables;
        my @columns;
        # $*ERR.say(@table-col-refs);
        for @table-col-refs {
            # $*ERR.say($(:TABLE($_<table>), :COLUMNS($_<columns>)));
            push |.list for @tables, @columns Z $_<table>, $_<columns>;
        }
        # $*ERR.say($(:@tables, :@columns));
        for @tables {
            $_ = self.table($_);
        }
        @columns».=Str;
        # $*ERR.say($(:@tables, :@columns).perl);

        my @refs = (@tables Z @columns).flat;

        while @refs {
            with ($prefix, @refs.map({ .list })).flat.join('-') {
                .return if .chars <= MAX_INDEX_LENGTH;
            }
            @refs.pop;
        }
        die "too long index name in any case";
    }

    method rename-table(Match:D $s, Bool:D :$back = False --> Str) {
        my ($from_table, $to_table) = $s<table rename_table>;
        $to_table = $to_table<table>;
        ($from_table, $to_table) = $to_table, $from_table if $back;
        [~] '$this->renameTable(',
            self.table-string($from_table), ', ',
            self.table-string($to_table), ');';
    }

    method alter-column-name(Match:D $s, Bool:D :$back = False --> Str) {
        my $table = $s<table>;
        my ($from_name, $to_name) = $s<alter_column><name alter_column_spec>;
        $from_name .= Str;
        $to_name = $to_name<alter_column_name><name>.Str;
        ($from_name, $to_name) = $to_name, $from_name if $back;
        [~] '$this->renameColumn(',
            self.table-string($table), ', ',
            self.string($from_name), ', ',
            self.string($to_name), ');';
    }
    method alter-column-type(Match:D $s, Bool:D :$back = False --> Str) {
        my $table = $s<table>;
        my ($name, $spec) = $s<alter_column><name alter_column_spec>;
        $name .= Str;
        my $type = $spec{$back ?? 'from' !! 'to'};
        [~] '$this->alterColumn(', "\n",
            $!indent x 3, self.table-string($table), ",\n",
            $!indent x 3, self.string($name), ",\n",
            $!indent x 3, self.column-type-pos($type), "\n",
            $!indent x 2, ');';
    }

    method data-statement(Match:D $s, Bool:D :$back = False --> Str) {
        [~] '// TODO: ',
            $back
                ?? 'undo that updates'
                !! 'add some updates';
    }

    submethod column-type-pos(Match:D $t --> Str) {
        my ($type, $pos) = $t<type position>;
        $type = self.column-type($type);
        return $type without $pos;
        return $type ~ '->first()' if $pos<pos_first>;
        return $type ~ '->after(' ~ self.string($pos<name>.Str) ~ ')';
    }

    submethod column-type(Match:D $t --> Str) {
        my ($name, $params, $null, $default) = $t<name params null_mark default_value>;
        $name .= Str;
        $params = $params
            ?? $params<number>».Str.join(', ')
            !! '';

        %types{$name}:exists or die "unknown type `$name`";
        my ($type, $appendix, $defined) = do given %types{$name} {
            when * === True { ($name,) }
            when Str:D { (.self,) }
            when List { .self }
            when Map { @(.self<t a D>) }
            default {
                die "bad type declaration for `$name`";
            }
        };

        my $ret = [~] '$this->', $type, '(', $params, ')';
        if $defined {
            with $null {
                self.throw-unsupported(
                    "type `$name` (`$type`) is strictly defined so it cannot be NULL"
                );
            }
        }
        else {
            $ret ~= '->notNull()' without $null;
        }
        $ret ~= '->defaultValue(' ~ self.default-value($default) ~ ')' with $default;
        $ret ~= * with $appendix;
        $ret;
    }

    method string(Str $s --> Str) {
        "'" ~ $s.subst(/(<[\\ ']>)/, { "\\$0" }, :g) ~ "'";
    }

    method table-string(Match:D $t --> Str) {
        self.string('{{%' ~ self.table($t) ~ '}}');
    }

    multi method fk-action-string(Match:D $on) {
        my $action = $on<fk_verb>.hash.keys[0];
        die "unexpected FK action `$action`" unless FK_ACTION{$action}:exists;
        self.string(FK_ACTION{$action});
    }
    multi method fk-action-string(Any:U) {
        self.string(FK_ACTION<fk_restrict>);
    }
}

sub transform(IO::Handle $input, TransformFormat $format) {
    my Int $line_number = 0;
    for $input.lines -> $line {
        ++$line_number;
        next unless $line.trim;
        my $statement;
        try {
            $statement = MigrationSource.parse($line, rule => 'statement');
            CATCH {
                when X::App::MatchFail {
                    abort "syntax: $_ - at line $line_number";
                }
            }
        }
        $statement or abort "cannot match at line $line_number\n";
        try {
            my $migration = $format.export-migration($statement);
            say $migration;
            CATCH {
                when X::App::Unsupported {
                    abort "unsupported: $_ - at line $line_number";
                }
            }
        }
    }
}

sub MAIN() {
    transform($*IN, Yii2Format.new(indent => ' ' x 4));
}
